<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>E2E Test Agents — Technical Documentation</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Inter:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
:root {
  --purple: #31135D;
  --purple-mid: #6D31C2;
  --purple-light: #8C68EE;
  --purple-bg: #F7F2FA;
  --ink: #1a1a1a;
  --ink-soft: #374151;
  --ink-muted: #6b7280;
  --ink-ghost: #9ca3af;
  --bg: #fafafa;
  --surface: #ffffff;
  --border: #e5e7eb;
  --green: #059669;
  --green-bg: #ecfdf5;
  --amber: #d97706;
  --amber-bg: #fffbeb;
  --red: #dc2626;
  --red-bg: #fef2f2;
  --blue: #2563eb;
  --blue-bg: #eff6ff;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Inter', -apple-system, sans-serif;
  color: var(--ink);
  background: var(--bg);
  line-height: 1.7;
  -webkit-font-smoothing: antialiased;
}

.page { max-width: 860px; margin: 0 auto; padding: 0 24px 80px; }

/* Hero */
.hero {
  background: linear-gradient(135deg, var(--purple) 0%, var(--purple-mid) 100%);
  padding: 64px 24px 56px;
  text-align: center;
  color: white;
  margin-bottom: 48px;
}
.hero__label {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 12px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  opacity: 0.7;
  margin-bottom: 16px;
}
.hero h1 {
  font-family: 'DM Sans', sans-serif;
  font-size: 2.5rem;
  font-weight: 700;
  letter-spacing: -0.02em;
  margin-bottom: 16px;
}
.hero p {
  font-size: 1.1rem;
  font-weight: 300;
  opacity: 0.85;
  max-width: 600px;
  margin: 0 auto;
  line-height: 1.7;
}
.hero__date {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 12px;
  opacity: 0.5;
  margin-top: 24px;
}

/* Snapshot bar */
.snapshot {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 12px;
  margin-bottom: 48px;
}
.snapshot__item {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px;
  text-align: center;
}
.snapshot__value {
  font-family: 'DM Sans', sans-serif;
  font-weight: 700;
  font-size: 1.75rem;
  color: var(--purple-mid);
}
.snapshot__label {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  font-weight: 500;
  color: var(--ink-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-top: 4px;
}

/* Section */
.section { margin-bottom: 56px; }
.section__number {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 12px;
  font-weight: 600;
  color: var(--purple-light);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 8px;
}
.section h2 {
  font-family: 'DM Sans', sans-serif;
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--purple);
  margin-bottom: 8px;
}
.section__subtitle {
  font-size: 0.95rem;
  color: var(--ink-muted);
  margin-bottom: 24px;
}
.section p, .section li {
  font-size: 0.95rem;
  color: var(--ink-soft);
  line-height: 1.75;
}
.section ul, .section ol {
  padding-left: 20px;
  margin-bottom: 16px;
}
.section li { margin-bottom: 8px; }

/* Proposal cards */
.proposal {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 28px;
  margin-bottom: 20px;
  transition: box-shadow 0.15s ease;
}
.proposal:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.06); }
.proposal__header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 12px;
}
.proposal h3 {
  font-family: 'DM Sans', sans-serif;
  font-size: 1.15rem;
  font-weight: 700;
  color: var(--ink);
  flex: 1;
}
.proposal__impact {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 20px;
  white-space: nowrap;
  flex-shrink: 0;
}
.impact--high { background: var(--green-bg); color: var(--green); }
.impact--medium { background: var(--amber-bg); color: var(--amber); }
.impact--low { background: var(--blue-bg); color: var(--blue); }
.impact--agent1 { background: var(--purple-bg); color: var(--purple-mid); }
.impact--agent2 { background: var(--blue-bg); color: var(--blue); }
.impact--shared { background: var(--green-bg); color: var(--green); }
.proposal__effort {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  font-weight: 500;
  padding: 4px 10px;
  border-radius: 20px;
  background: var(--purple-bg);
  color: var(--purple-mid);
  white-space: nowrap;
  flex-shrink: 0;
}
.proposal p {
  font-size: 0.9rem;
  color: var(--ink-soft);
  line-height: 1.7;
  margin-bottom: 12px;
}
.proposal__why {
  font-size: 0.85rem;
  color: var(--ink-muted);
  padding: 12px 16px;
  background: var(--bg);
  border-radius: 8px;
  border-left: 3px solid var(--purple-light);
  line-height: 1.6;
}
.proposal__tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 12px;
}
.tag {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 10px;
  font-weight: 500;
  padding: 3px 8px;
  border-radius: 4px;
  background: #f3f4f6;
  color: var(--ink-muted);
}

/* Divider */
hr {
  border: none;
  border-top: 1px solid var(--border);
  margin: 48px 0;
}

/* Code blocks */
code {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 0.85em;
  background: #f3f4f6;
  padding: 2px 6px;
  border-radius: 4px;
  color: var(--purple-mid);
}
pre {
  background: #1e1e2e;
  color: #cdd6f4;
  padding: 20px;
  border-radius: 10px;
  overflow-x: auto;
  font-family: 'IBM Plex Mono', monospace;
  font-size: 13px;
  line-height: 1.6;
  margin: 16px 0;
}

/* Diagram */
.diagram {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 32px;
  margin: 24px 0;
  text-align: center;
}
.diagram pre {
  background: transparent;
  color: var(--ink-soft);
  text-align: left;
  padding: 0;
  font-size: 13px;
  line-height: 1.5;
}

/* Callout */
.callout {
  padding: 20px 24px;
  border-radius: 12px;
  margin: 20px 0;
}
.callout--insight { background: var(--purple-bg); border-left: 4px solid var(--purple-mid); }
.callout--warning { background: var(--amber-bg); border-left: 4px solid var(--amber); }
.callout--success { background: var(--green-bg); border-left: 4px solid var(--green); }
.callout__title {
  font-family: 'DM Sans', sans-serif;
  font-weight: 700;
  font-size: 0.9rem;
  margin-bottom: 6px;
}
.callout--insight .callout__title { color: var(--purple-mid); }
.callout--warning .callout__title { color: var(--amber); }
.callout--success .callout__title { color: var(--green); }
.callout p { font-size: 0.88rem; }

/* Priority matrix */
.matrix {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin: 24px 0;
}
.matrix__quadrant {
  padding: 20px;
  border-radius: 12px;
  border: 1px solid var(--border);
}
.matrix__quadrant h4 {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  margin-bottom: 10px;
}
.matrix__quadrant ul { padding-left: 16px; }
.matrix__quadrant li { font-size: 0.85rem; color: var(--ink-soft); margin-bottom: 4px; }
.q-now { background: var(--green-bg); }
.q-now h4 { color: var(--green); }
.q-next { background: var(--blue-bg); }
.q-next h4 { color: var(--blue); }
.q-later { background: var(--amber-bg); }
.q-later h4 { color: var(--amber); }
.q-maybe { background: #f3f4f6; }
.q-maybe h4 { color: var(--ink-muted); }

/* Flow step */
.flow-step {
  display: flex;
  gap: 16px;
  margin-bottom: 16px;
  align-items: flex-start;
}
.flow-step__number {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 12px;
  font-weight: 600;
  color: white;
  background: var(--purple-mid);
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  margin-top: 2px;
}
.flow-step__content {
  flex: 1;
}
.flow-step__title {
  font-family: 'DM Sans', sans-serif;
  font-weight: 700;
  font-size: 0.95rem;
  color: var(--ink);
  margin-bottom: 2px;
}
.flow-step__desc {
  font-size: 0.85rem;
  color: var(--ink-muted);
  line-height: 1.6;
}

/* Table */
.data-table {
  width: 100%;
  border-collapse: collapse;
  margin: 16px 0;
  font-size: 0.85rem;
}
.data-table th {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--ink-muted);
  text-align: left;
  padding: 10px 12px;
  border-bottom: 2px solid var(--border);
}
.data-table td {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  color: var(--ink-soft);
}
.data-table tr:hover td {
  background: var(--purple-bg);
}

/* Code section with copy */
.code-section {
  position: relative;
  margin: 16px 0;
}
.code-section pre {
  max-height: 500px;
  overflow-y: auto;
}
.copy-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  background: rgba(255,255,255,0.12);
  color: #cdd6f4;
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 6px;
  padding: 6px 14px;
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;
  z-index: 10;
}
.copy-btn:hover {
  background: rgba(255,255,255,0.2);
  color: white;
}
.copy-btn.copied {
  background: var(--green);
  color: white;
  border-color: var(--green);
}

/* Collapsible */
.code-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  cursor: pointer;
  font-family: 'DM Sans', sans-serif;
  font-size: 1rem;
  font-weight: 700;
  color: var(--ink);
  padding: 0;
  margin-bottom: 8px;
}
.code-toggle .arrow {
  display: inline-block;
  transition: transform 0.2s ease;
  font-size: 0.8em;
  color: var(--purple-mid);
}
.code-toggle[aria-expanded="true"] .arrow {
  transform: rotate(90deg);
}
.code-collapse {
  display: none;
}
.code-collapse.open {
  display: block;
}

@media (max-width: 600px) {
  .hero h1 { font-size: 1.75rem; }
  .snapshot { grid-template-columns: repeat(2, 1fr); }
  .matrix { grid-template-columns: 1fr; }
  .proposal__header { flex-direction: column; }
}
</style>
</head>
<body>

<div class="hero">
  <div class="hero__label">Split Lease &middot; E2E Test Suite</div>
  <h1>Dual-Agent Proposal Journey</h1>
  <p>Technical documentation for the two-agent Playwright + Bubble API test system that automates and verifies the full listing&ndash;proposal&ndash;counter&ndash;acceptance lifecycle on app.split.lease.</p>
  <div class="hero__date">February 19, 2026</div>
</div>

<div class="page">

<!-- SNAPSHOT -->
<div class="snapshot">
  <div class="snapshot__item">
    <div class="snapshot__value">2</div>
    <div class="snapshot__label">Parallel Agents</div>
  </div>
  <div class="snapshot__item">
    <div class="snapshot__value">4</div>
    <div class="snapshot__label">Lifecycle Phases</div>
  </div>
  <div class="snapshot__item">
    <div class="snapshot__value">23</div>
    <div class="snapshot__label">Automated Steps</div>
  </div>
  <div class="snapshot__item">
    <div class="snapshot__value">2</div>
    <div class="snapshot__label">Site Profiles</div>
  </div>
  <div class="snapshot__item">
    <div class="snapshot__value">3</div>
    <div class="snapshot__label">Verification Layers</div>
  </div>
</div>

<!-- ARCHITECTURE OVERVIEW -->
<div class="section">
  <div class="section__number">Overview</div>
  <h2>Two Agents, One Journey, Three Layers of Truth</h2>
  <p class="section__subtitle">A parallel test architecture that validates the proposal lifecycle from UI, backend API, and database.</p>

  <p>The test suite consists of two scripts that run concurrently. <strong>Agent 1</strong> (<code>proposal-journey-bubble.cjs</code>) drives a real browser through the complete host&ndash;guest proposal flow&mdash;creating listings, submitting proposals, countering terms, and accepting. <strong>Agent 2</strong> (<code>bubble-price-tracker.cjs</code>) runs headlessly alongside, polling the Bubble Data API to capture every backend price and status change as it happens.</p>

  <p>Together they produce three independent views of the same transaction: what the <em>user saw</em> (screenshots + scraped prices), what the <em>API reported</em> (Bubble Data API snapshots), and what the <em>database stored</em> (Supabase verification). Discrepancies between these layers surface pricing bugs that neither a pure UI test nor a pure API test would catch alone.</p>

  <div class="diagram">
    <pre>
  Agent 1 (Playwright Browser)              Agent 2 (Bubble Data API)
  ───────────────────────────               ─────────────────────────
  Phase 1: Host creates listing
       │
       ├── writes listing-signal.json ───▶  Detects signal, fetches listing
       │                                         │
  Phase 2: Guest creates proposal          Polls for new Proposal object
       │                                         │
  Phase 3: Host counters                   Detects price/status diff
       │                                         │
  Phase 4: Guest accepts                   Detects acceptance, final snapshot
       │                                         │
  Backend Observer (Supabase) ◀─── both write to same run directory ───▶
       │
  ┌────▼─────────────────────────────────────────────────────────┐
  │  recordings/{site}/{timestamp}/                              │
  │    ├── screenshots/           (23 PNGs)                      │
  │    ├── test-images/           (generated upload images)      │
  │    ├── price-log.json         (Agent 1 UI-scraped prices)    │
  │    ├── backend-price-tracker-log.json  (Agent 2 API prices)  │
  │    ├── backend-price-summary.txt       (cross-phase table)   │
  │    ├── verification-report.json        (Supabase check)      │
  │    ├── listing-signal.json    (Agent 1 → Agent 2 handoff)    │
  │    ├── listing-raw-fields.json                               │
  │    ├── proposal-raw-fields.json                              │
  │    └── *.webm                 (video recording)              │
  └──────────────────────────────────────────────────────────────┘
    </pre>
  </div>

  <div class="callout callout--insight">
    <div class="callout__title">Why two agents?</div>
    <p>Bubble.io renders prices client-side through workflows that may compute differently than the Data API returns. Agent 1 captures what users see; Agent 2 captures what the backend believes. If these diverge&mdash;a nightly rate shows $50 in the UI but $45 in the API&mdash;there's a pricing workflow bug. A single-agent approach can only test one of these surfaces at a time.</p>
  </div>
</div>

<hr>

<!-- AGENT 1 -->
<div class="section">
  <div class="section__number">Agent 1</div>
  <h2>proposal-journey-bubble.cjs</h2>
  <p class="section__subtitle">Playwright browser automation &mdash; 1,180 lines &mdash; drives the full host/guest flow end-to-end.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Purpose &amp; Responsibilities</h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
      <span class="proposal__effort">Playwright</span>
    </div>
    <p>This script launches a headed Chromium browser (with video recording) and walks through the entire Split Lease proposal lifecycle as both a host and a guest user. It logs in, fills forms, clicks buttons, scrapes visible prices, takes screenshots at every milestone, and verifies the resulting listing against Supabase.</p>
    <p>It also coordinates with Agent 2 by writing a <code>listing-signal.json</code> file after listing creation and a <code>price-log.json</code> file that Agent 2 monitors for early termination.</p>
    <div class="proposal__tags">
      <span class="tag">playwright</span>
      <span class="tag">chromium</span>
      <span class="tag">supabase</span>
      <span class="tag">video recording</span>
      <span class="tag">screenshots</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>CLI Interface</h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
      <span class="proposal__effort">Configuration</span>
    </div>
<pre>node proposal-journey-bubble.cjs [options]

Options:
  --site=app.split.lease    Target site profile (default: app.split.lease)
  --site=split.lease        Use the production site profile instead

  --skip-to=phase2          Skip listing creation, start at guest proposal
  --skip-to=phase3          Skip to host counter-offer
  --skip-to=phase4          Skip to guest acceptance

  --listing-url=&lt;url&gt;       Required when using --skip-to (which listing to target)</pre>
    <div class="proposal__why">
      <strong>Skip-to mode:</strong> When iterating on later phases (e.g. debugging the counter-offer flow), you can skip listing creation entirely by providing an existing listing URL. The script navigates to the homepage, logs in the appropriate user, and picks up mid-flow.
    </div>
    <div class="proposal__tags">
      <span class="tag">--site</span>
      <span class="tag">--skip-to</span>
      <span class="tag">--listing-url</span>
    </div>
  </div>
</div>

<hr>

<!-- PHASE BREAKDOWN (condensed) -->
<div class="section">
  <div class="section__number">Phases</div>
  <h2>The Two-Stage Pipeline</h2>
  <p class="section__subtitle">Agent 1 drives the browser through the full proposal journey, then verifies against Supabase.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Phase 1 &mdash; Autonomous Proposal Journey</h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
      <span class="proposal__effort">23 Steps &middot; ~13 min</span>
    </div>
    <p>Playwright drives the complete host&ndash;guest lifecycle in a single headed browser session: host creates a listing through the 6-section wizard (address, features, lease style, pricing, rules, photos), guest creates a proposal with custom duration, host counters by editing the terms, and guest accepts. Each phase includes login/logout, price scraping from the UI, and screenshots at every milestone. Agent 2 watches the Bubble Data API in parallel, capturing backend prices and diffs.</p>
    <div class="proposal__why">
      <strong>All selectors come from codegen:</strong> Every <code>getByRole</code>, <code>getByText</code>, <code>locator</code>, and <code>selectOption</code> call was captured from a live Playwright codegen recording session (Feb 9, 2026). Bubble's opaque class names (<code>.cmaRhaT</code>, <code>.cvaAaIi12</code>) and internal option values (<code>"1348695171700984260__LOOKUP__..."</code>) are replayed exactly as recorded.
    </div>
    <div class="proposal__tags">
      <span class="tag">playwright codegen</span>
      <span class="tag">4 login/logout cycles</span>
      <span class="tag">23 screenshots</span>
      <span class="tag">video recording</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Final &mdash; Backend Observer (Supabase)</h3>
      <span class="proposal__impact impact--medium">Verification</span>
      <span class="proposal__effort">~5 sec</span>
    </div>
    <p>After the journey completes, Agent 1 queries Supabase directly (REST API with anon key) and compares 8 listing fields&mdash;name, space type, bedrooms, kitchen, parking, bathrooms, rental type, and active status&mdash;against what was submitted through the UI. Generates a field-by-field <code>verification-report.json</code> with MATCH/MISMATCH results. Foreign key fields (type of space, parking) are checked for existence rather than exact value match.</p>
    <div class="proposal__tags">
      <span class="tag">Supabase REST</span>
      <span class="tag">verification-report.json</span>
      <span class="tag">8-field comparison</span>
    </div>
  </div>
</div>

<hr>

<!-- AGENT 2 -->
<div class="section">
  <div class="section__number">Agent 2</div>
  <h2>bubble-price-tracker.cjs</h2>
  <p class="section__subtitle">Headless Bubble Data API poller &mdash; 580 lines &mdash; captures backend prices across the proposal lifecycle.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Purpose &amp; Responsibilities</h3>
      <span class="proposal__impact impact--agent2">Agent 2</span>
      <span class="proposal__effort">Bubble API</span>
    </div>
    <p>This script runs in parallel with Agent 1 (no browser). It watches for the <code>listing-signal.json</code> file that Agent 1 writes after creating a listing, then polls the Bubble Data API every 10 seconds to capture backend price data at each lifecycle stage. It detects proposal creation, counter-offers, and acceptance by diffing snapshots. All events are written to a structured log with a final cross-phase comparison table.</p>
    <div class="proposal__tags">
      <span class="tag">Bubble Data API</span>
      <span class="tag">polling</span>
      <span class="tag">diff detection</span>
      <span class="tag">no browser</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>CLI Interface</h3>
      <span class="proposal__impact impact--agent2">Agent 2</span>
      <span class="proposal__effort">Configuration</span>
    </div>
<pre>node bubble-price-tracker.cjs [options]

Options:
  --site=app.split.lease    Target site (default: app.split.lease)
  --api-key=&lt;key&gt;           Bubble Data API key
                            Falls back to: BUBBLE_API_KEY env
                                           VITE_BUBBLE_API_KEY env
                                           hardcoded default key</pre>
    <div class="proposal__tags">
      <span class="tag">--site</span>
      <span class="tag">--api-key</span>
      <span class="tag">env vars</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Signal File Handoff</h3>
      <span class="proposal__impact impact--shared">Coordination</span>
      <span class="proposal__effort">File-based IPC</span>
    </div>
    <p>Agent 2 polls the filesystem for <code>recordings/{site}/latest.txt</code> every 3 seconds (up to 10 minutes). When found, it reads the run timestamp pointer, then checks for <code>{timestamp}/listing-signal.json</code>. The signal contains the listing ID, URL, title, and run directory&mdash;everything Agent 2 needs to start tracking.</p>
<pre>{
  "listingId": "1738295847261x293847562938475",
  "listingURL": "https://app.split.lease/view-split-lease/1738...",
  "listingTitle": "PW Test 02-19 14:30:00",
  "runDir": "recordings/app-split-lease/2026-02-19_14-30-00",
  "timestamp": "2026-02-19T14:30:05.123Z"
}</pre>
    <div class="proposal__why">
      <strong>Why file-based IPC?</strong> Both agents are independent Node.js processes. File-based signaling is dead simple, requires no shared-memory or socket coordination, and the signal file doubles as a debugging artifact. Agent 2 can also be started before Agent 1&mdash;it just waits.
    </div>
    <div class="proposal__tags">
      <span class="tag">listing-signal.json</span>
      <span class="tag">latest.txt</span>
      <span class="tag">filesystem polling</span>
    </div>
  </div>
</div>

<hr>

<!-- BUBBLE API DETAILS -->
<div class="section">
  <div class="section__number">API Layer</div>
  <h2>Bubble Data API Integration</h2>
  <p class="section__subtitle">How Agent 2 fetches and diffs backend data without touching a browser.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3>API Client</h3>
      <span class="proposal__impact impact--agent2">Agent 2</span>
      <span class="proposal__effort">REST Client</span>
    </div>
    <p>Two core functions power all API access:</p>
    <ul>
      <li><code>bubbleGet(objectType, constraints, sortField, descending, limit)</code> &mdash; search objects with Bubble constraint syntax</li>
      <li><code>bubbleGetById(objectType, uniqueId)</code> &mdash; direct lookup by Bubble <code>_id</code></li>
    </ul>
    <p>Both hit <code>https://app.split.lease/api/1.1/obj/{type}</code> with Bearer token auth. Constraints use Bubble's native format: <code>[{ key, constraint_type, value }]</code>.</p>
    <div class="proposal__tags">
      <span class="tag">bubbleGet()</span>
      <span class="tag">bubbleGetById()</span>
      <span class="tag">Bearer auth</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Tracked Listing Fields</h3>
      <span class="proposal__impact impact--agent2">Agent 2</span>
      <span class="proposal__effort">17 Fields</span>
    </div>
    <p>The <code>extractListingPriceFields()</code> function pulls these pricing and schedule fields from each listing snapshot:</p>
    <table class="data-table">
      <thead>
        <tr><th>Category</th><th>Fields</th></tr>
      </thead>
      <tbody>
        <tr><td>Nightly Rates</td><td>Host rates for 2, 3, 4, 5, and 7 nights</td></tr>
        <tr><td>Fees</td><td>Cleaning/Maintenance, Damage Deposit, Unit Markup</td></tr>
        <tr><td>Computed Prices</td><td>Standardized Min Nightly Price, Price for map, Pricing list</td></tr>
        <tr><td>Schedule</td><td>Min/Max Nights, Min/Max Weeks, Weeks offered, Nights available</td></tr>
        <tr><td>Status</td><td>Active, Complete, Modified Date</td></tr>
      </tbody>
    </table>
    <div class="proposal__tags">
      <span class="tag">extractListingPriceFields()</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Tracked Proposal Fields</h3>
      <span class="proposal__impact impact--agent2">Agent 2</span>
      <span class="proposal__effort">22 Fields</span>
    </div>
    <p>The <code>extractProposalPriceFields()</code> function pulls these fields from each proposal snapshot:</p>
    <table class="data-table">
      <thead>
        <tr><th>Category</th><th>Fields</th></tr>
      </thead>
      <tbody>
        <tr><td>Pricing</td><td>Nightly price, Host compensation, 4-week rent, Total compensation (host), Total reservation price (guest), Cleaning fee, Damage deposit</td></tr>
        <tr><td>Duration</td><td>Reservation Span, Span in Weeks, Actual weeks, Nights per week, Days selected, Nights list, Check-in/out day, Week selection</td></tr>
        <tr><td>Dates</td><td>Move-in range start, Move-out</td></tr>
        <tr><td>Status</td><td>Status, Is Finalized, Rental type, History, Created/Modified Date</td></tr>
      </tbody>
    </table>
    <div class="proposal__tags">
      <span class="tag">extractProposalPriceFields()</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Snapshot Diffing</h3>
      <span class="proposal__impact impact--agent2">Agent 2</span>
      <span class="proposal__effort">Change Detection</span>
    </div>
    <p>Every 10 seconds, Agent 2 re-fetches the proposal and listing, extracts fields, and runs <code>diffSnapshots(prev, curr)</code>. This compares all fields (except timestamps) via JSON serialization and produces a change object: <code>{ field: { from: old, to: new } }</code>. The diff classifies changes into four categories:</p>
    <ul>
      <li><strong>PROPOSAL_CREATED</strong> &mdash; first time a Proposal object appears linked to the listing</li>
      <li><strong>COUNTER_OFFER</strong> &mdash; price or duration fields changed, or status contains "counter"</li>
      <li><strong>ACCEPTED</strong> &mdash; <code>Is Finalized</code> changed, or status contains "accept"</li>
      <li><strong>LISTING_UPDATED</strong> &mdash; any listing field changed (pricing recalculation, activation, etc.)</li>
    </ul>
    <div class="proposal__tags">
      <span class="tag">diffSnapshots()</span>
      <span class="tag">10s polling</span>
      <span class="tag">60 max polls</span>
    </div>
  </div>
</div>

<hr>

<!-- COORDINATION -->
<div class="section">
  <div class="section__number">Coordination</div>
  <h2>How the Agents Communicate</h2>
  <p class="section__subtitle">File-based signaling, shared output directories, and graceful termination.</p>

  <div class="diagram">
    <pre>
  Time ──────────────────────────────────────────────────────────▶

  Agent 1 (Browser)
  ├─ launches browser
  ├─ host login
  ├─ listing wizard (steps 4-12)
  ├─ writes latest.txt ─────────────────────┐
  ├─ writes listing-signal.json ────────────┤
  ├─ host sign-out                          │
  ├─ guest login                            │
  ├─ create proposal ──────── UI prices     │
  ├─ submit proposal                        │
  ├─ writes price-log.json ─────────────┐   │
  ├─ guest sign-out                     │   │
  ├─ host login                         │   │
  ├─ host counters ──────── UI prices   │   │
  ├─ updates price-log.json             │   │
  ├─ host sign-out                      │   │
  ├─ guest login                        │   │
  ├─ guest accepts ──────── UI prices   │   │
  ├─ updates price-log.json (ACCEPTANCE)│   │
  ├─ Supabase verification             │   │
  └─ DONE                              │   │
                                        │   │
  Agent 2 (API Poller)                  │   │
  ├─ polls for latest.txt ◀─────────────┼───┘
  ├─ reads listing-signal.json          │
  ├─ fetches listing ──── API prices    │
  ├─ polls for proposal (10s loop) ◀────┼── detects new Proposal
  ├─ detects counter-offer diff         │
  ├─ detects acceptance diff            │
  ├─ reads price-log.json ◀────────────┘   checks for ACCEPTANCE phase
  ├─ final snapshot
  ├─ writes backend-price-summary.txt
  └─ DONE
    </pre>
  </div>

  <div class="callout callout--warning">
    <div class="callout__title">Termination strategy</div>
    <p>Agent 2 has two exit conditions: (1) it detects <code>Is Finalized</code> or an "accept" status change in the Bubble API, or (2) it reads Agent 1's <code>price-log.json</code> and finds an entry with <code>phase: "ACCEPTANCE"</code>. The second path is a fallback&mdash;if Bubble's API doesn't immediately reflect the acceptance, Agent 2 still knows to stop because Agent 1 confirmed it in the UI. After either trigger, Agent 2 does one final 5-second delay + fetch to capture the settled state.</p>
  </div>
</div>

<hr>

<!-- SITE PROFILES -->
<div class="section">
  <div class="section__number">Configuration</div>
  <h2>Site Profiles &amp; Test Data</h2>
  <p class="section__subtitle">Both agents share the same site profile system for targeting staging vs. production.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Site Profiles</h3>
      <span class="proposal__impact impact--shared">Both Agents</span>
      <span class="proposal__effort">2 Profiles</span>
    </div>
    <table class="data-table">
      <thead>
        <tr><th>Profile</th><th>Base URL</th><th>Host Account</th><th>Guest Account</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><code>app.split.lease</code></td>
          <td>https://app.split.lease</td>
          <td>rodtesthost2@test.com</td>
          <td>splitleasetesting@test.com</td>
        </tr>
        <tr>
          <td><code>split.lease</code></td>
          <td>https://split.lease</td>
          <td>rodtesthost@test.com</td>
          <td>splitleasetesting@test.com</td>
        </tr>
      </tbody>
    </table>
    <div class="proposal__tags">
      <span class="tag">SITE_PROFILES</span>
      <span class="tag">--site flag</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Default Listing Configuration</h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
      <span class="proposal__effort">CONFIG Object</span>
    </div>
    <table class="data-table">
      <thead>
        <tr><th>Field</th><th>Value</th></tr>
      </thead>
      <tbody>
        <tr><td>Title</td><td><code>PW Test {MM-DD HH:MM:SS}</code> (auto-generated)</td></tr>
        <tr><td>Type of Space</td><td>Private Room</td></tr>
        <tr><td>Bedrooms</td><td>Studio</td></tr>
        <tr><td>Kitchen</td><td>Full Kitchen</td></tr>
        <tr><td>Parking</td><td>Street Parking</td></tr>
        <tr><td>Bathrooms</td><td>2</td></tr>
        <tr><td>Address</td><td>234 W 42nd St, New York</td></tr>
        <tr><td>Lease Style</td><td>Nights-of-the-week</td></tr>
        <tr><td>Initial Duration</td><td>6 weeks (URL) &rarr; 16 weeks (combobox)</td></tr>
        <tr><td>Counter Duration</td><td>10 weeks</td></tr>
        <tr><td>Days Selected</td><td>All 7 (Mon&ndash;Sun)</td></tr>
      </tbody>
    </table>
    <div class="proposal__tags">
      <span class="tag">CONFIG</span>
      <span class="tag">BUBBLE_VALUES</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Browser Settings</h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
      <span class="proposal__effort">Playwright Config</span>
    </div>
    <table class="data-table">
      <thead>
        <tr><th>Setting</th><th>Value</th></tr>
      </thead>
      <tbody>
        <tr><td>Headless</td><td><code>false</code> (visible browser)</td></tr>
        <tr><td>Slow Motion</td><td>300ms between actions</td></tr>
        <tr><td>Viewport</td><td>1280 &times; 720</td></tr>
        <tr><td>Video Recording</td><td>Enabled (1280 &times; 720 WebM)</td></tr>
        <tr><td>Navigation Timeout</td><td>60 seconds</td></tr>
        <tr><td>Action Timeout</td><td>30 seconds</td></tr>
        <tr><td>Clipboard Permissions</td><td>Granted (for URL extraction)</td></tr>
      </tbody>
    </table>
    <div class="proposal__tags">
      <span class="tag">slowMo: 300</span>
      <span class="tag">recordVideo</span>
      <span class="tag">clipboard-read/write</span>
    </div>
  </div>
</div>

<hr>

<!-- KEY FUNCTIONS -->
<div class="section">
  <div class="section__number">Key Functions</div>
  <h2>Core Helper Functions</h2>
  <p class="section__subtitle">Shared utilities that handle authentication, UI navigation, price scraping, and image generation.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3><code>loginAs(page, email, password, label)</code></h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
    </div>
    <p>Authenticates a user via the Bubble auth modal. Clicks "Sign In | Sign Up" &rarr; "Log into my account" &rarr; fills email and password &rarr; clicks "Login" &rarr; waits 15 seconds for Bubble's auth workflow to complete. Used four times: host login (Phase 1), guest login (Phase 2), host re-login (Phase 3), guest re-login (Phase 4).</p>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3><code>signOut(page, label)</code></h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
    </div>
    <p>Robust sign-out with three fallback strategies. First dismisses any blocking modals ("Ignore", "Close", "Cancel", "No Thanks") and greyout overlays. Then tries: (1) avatar dropdown &rarr; "Sign Out", (2) navigate to homepage first then retry, (3) find any "Sign Out" text on page. Waits 10 seconds for completion.</p>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3><code>extractListingURL(page, label)</code></h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
    </div>
    <p>Extracts the listing view URL using three strategies: (1) intercept <code>navigator.clipboard.writeText</code> and click "Copy Listing Link", (2) search for <code>a[href*="view-split-lease"]</code> in the DOM, (3) extract a Bubble unique ID (pattern: <code>\d{10,}x\d{10,}</code>) from the current URL and construct the view URL.</p>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3><code>scrapePrices(page, selectors)</code></h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
    </div>
    <p>Takes a map of <code>{ name: async (page) => string }</code> functions, runs each against the page, and returns a price object. Each scraper function uses Playwright text locators with regex (e.g., <code>text=/\$[\d,.]+\s*\/\s*night/i</code>) to find dollar amounts. Non-fatal&mdash;null if any individual scraper fails.</p>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3><code>generateTestImages(count)</code></h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
    </div>
    <p>Creates valid PNG files from scratch without any image library. Builds raw PNG binary data (signature, IHDR, IDAT with zlib-compressed pixel data, IEND) with a custom CRC-32 implementation. Generates 10&times;10 pixel solid-color images (red, green, blue). These are uploaded as listing photos to test the photo upload workflow.</p>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3><code>diffSnapshots(prev, curr)</code></h3>
      <span class="proposal__impact impact--agent2">Agent 2</span>
    </div>
    <p>Compares two field-extracted snapshots. Returns <code>{ changed: bool, isNew: bool, fields: { key: { from, to } } }</code>. Skips timestamp fields. Uses <code>JSON.stringify</code> comparison to handle nested objects and arrays. The caller classifies the diff as a counter-offer, acceptance, or generic update based on which fields changed.</p>
  </div>
</div>

<hr>

<!-- OUTPUT FILES -->
<div class="section">
  <div class="section__number">Outputs</div>
  <h2>Run Output Directory Structure</h2>
  <p class="section__subtitle">Everything both agents produce lives under <code>recordings/{site}/{timestamp}/</code>.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Directory Layout</h3>
      <span class="proposal__impact impact--shared">Both Agents</span>
    </div>
<pre>recordings/
  app-split-lease/
    latest.txt                          ← pointer to current run timestamp
    2026-02-19_14-30-00/
      ├── screenshots/
      │   ├── 01-homepage.png
      │   ├── 02-host-logged-in.png
      │   ├── 03-host-dashboard.png
      │   ├── 04-wizard-loaded.png
      │   ├── 05-address-filled.png
      │   ├── 06-listing-submitted.png
      │   ├── 07-manage-listing.png
      │   ├── 08-host-signed-out.png
      │   ├── 09-guest-logged-in.png
      │   ├── 10-listing-page.png
      │   ├── 11-proposal-created.png
      │   ├── 12-proposal-submitted.png
      │   ├── 13-guest-signed-out.png
      │   ├── 14-host-logged-in-again.png
      │   ├── 15-host-dashboard-proposals.png
      │   ├── 16-proposal-page.png
      │   ├── 17-proposal-review.png
      │   ├── 18-terms-edited.png
      │   ├── 19-proposal-countered.png
      │   ├── 20-host-signed-out-again.png
      │   ├── 21-guest-logged-in-again.png
      │   ├── 22-guest-proposals.png
      │   └── 23-terms-accepted.png
      ├── test-images/
      │   ├── test-image-1.png          ← red 10x10
      │   ├── test-image-2.png          ← green 10x10
      │   └── test-image-3.png          ← blue 10x10
      ├── listing-signal.json           ← Agent 1 → Agent 2 handoff
      ├── price-log.json                ← Agent 1 UI-scraped prices
      ├── verification-report.json      ← Agent 1 Supabase check
      ├── backend-price-tracker-log.json← Agent 2 full event log
      ├── backend-price-summary.txt     ← Agent 2 cross-phase table
      ├── listing-raw-fields.json       ← Agent 2 raw Bubble listing
      ├── proposal-raw-fields.json      ← Agent 2 raw Bubble proposal
      ├── proposal-raw-fields-counter_offer.json
      ├── proposal-raw-fields-accepted.json
      └── *.webm                        ← Playwright video recording</pre>
    <div class="proposal__tags">
      <span class="tag">screenshots</span>
      <span class="tag">JSON logs</span>
      <span class="tag">video</span>
      <span class="tag">raw API data</span>
    </div>
  </div>
</div>

<hr>

<!-- PRICE TRACKING -->
<div class="section">
  <div class="section__number">Price Tracking</div>
  <h2>Three-Layer Price Verification</h2>
  <p class="section__subtitle">Every price is captured from UI, API, and database for cross-validation.</p>

  <div class="matrix">
    <div class="matrix__quadrant q-now">
      <h4>Agent 1 &mdash; UI Prices</h4>
      <ul>
        <li>Listing page: nightly rate, 4-week rent</li>
        <li>Proposal modal: price/night, total reservation, first 4 weeks</li>
        <li>Counter-offer: compensation/night, duration, total</li>
        <li>Acceptance: nightly rate, duration, total</li>
      </ul>
    </div>
    <div class="matrix__quadrant q-next">
      <h4>Agent 2 &mdash; API Prices</h4>
      <ul>
        <li>Listing: 5 nightly rate tiers, fees, computed prices</li>
        <li>Proposal: nightly price, host comp, 4-week rent, totals</li>
        <li>Counter diff: which fields changed &amp; by how much</li>
        <li>Final state: settled values after acceptance</li>
      </ul>
    </div>
    <div class="matrix__quadrant q-later">
      <h4>Supabase &mdash; Database</h4>
      <ul>
        <li>Listing name, space type, bedrooms</li>
        <li>Kitchen, parking, bathrooms</li>
        <li>Rental type, active status</li>
        <li>Field-by-field MATCH/MISMATCH</li>
      </ul>
    </div>
    <div class="matrix__quadrant q-maybe">
      <h4>Cross-Phase Summary</h4>
      <ul>
        <li>Agent 2 generates a comparison table</li>
        <li>All price fields across all phases</li>
        <li>Saved as <code>backend-price-summary.txt</code></li>
        <li>Visual diff of what changed and when</li>
      </ul>
    </div>
  </div>
</div>

<hr>

<!-- ERROR HANDLING -->
<div class="section">
  <div class="section__number">Resilience</div>
  <h2>Error Handling &amp; Recovery Patterns</h2>
  <p class="section__subtitle">Both agents use multi-strategy approaches to handle Bubble's dynamic UI and API inconsistencies.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Bubble UI Challenges (Agent 1)</h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
      <span class="proposal__effort">Workarounds</span>
    </div>
    <p>Bubble.io presents several automation challenges that the script addresses with specific patterns:</p>
    <ul>
      <li><strong>Greyout overlays:</strong> Bubble renders semi-transparent overlays (<code>.greyout</code>) that block clicks. The script proactively checks for and clicks these to dismiss them before every major interaction.</li>
      <li><strong>Animated buttons:</strong> Bubble animates button transitions, causing Playwright's "element not stable" errors. Solved with <code>{ force: true }</code> clicks that bypass stability checks.</li>
      <li><strong>Avatar outside viewport:</strong> After proposal submission, the page may be scrolled down. The script scrolls to top first, then falls back to <code>.evaluate((el) => el.click())</code> for JavaScript-level clicks that don't need the element in viewport.</li>
      <li><strong>Modal dismissal:</strong> Unexpected modals (suggestions, confirmations, notifications) are tried and caught individually. Four dismiss texts are attempted in sequence: "Ignore", "Close", "Cancel", "No Thanks".</li>
      <li><strong>Long waits:</strong> Bubble's server-side workflows can take 10&ndash;60 seconds. The script uses generous <code>waitForTimeout</code> calls (15&ndash;60s) after login, page navigation, and wizard section transitions.</li>
    </ul>
    <div class="proposal__tags">
      <span class="tag">greyout</span>
      <span class="tag">force click</span>
      <span class="tag">JS click</span>
      <span class="tag">modal dismiss</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>API Resilience (Agent 2)</h3>
      <span class="proposal__impact impact--agent2">Agent 2</span>
      <span class="proposal__effort">Fallbacks</span>
    </div>
    <p>Agent 2 handles API instability with layered fallbacks:</p>
    <ul>
      <li><strong>Direct ID vs. search:</strong> Tries <code>bubbleGetById</code> first; if that fails (404 or permission error), falls back to constraint-based search by name.</li>
      <li><strong>Non-fatal polling:</strong> Each 10-second poll iteration wraps all API calls in try/catch. A failed poll logs the error and continues rather than crashing.</li>
      <li><strong>Listing check is secondary:</strong> The listing re-check (for price changes during the proposal lifecycle) is wrapped in an additional try/catch so a listing API failure doesn't stop proposal tracking.</li>
      <li><strong>Dual exit signals:</strong> Watches both the API response (<code>Is Finalized</code>) and Agent 1's filesystem output (<code>price-log.json</code>) for termination, ensuring it stops even if one signal path fails.</li>
    </ul>
    <div class="proposal__tags">
      <span class="tag">try/catch</span>
      <span class="tag">ID fallback</span>
      <span class="tag">dual exit</span>
    </div>
  </div>
</div>

<hr>

<!-- HOW TO RUN -->
<div class="section">
  <div class="section__number">Usage</div>
  <h2>Running the Test Suite</h2>
  <p class="section__subtitle">Launch both agents in parallel for full coverage, or run Agent 1 alone for UI-only testing.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Full Dual-Agent Run</h3>
      <span class="proposal__impact impact--shared">Both Agents</span>
      <span class="proposal__effort">~13 min</span>
    </div>
    <p>Open two terminals. Start Agent 2 first (it will wait for the signal file), then start Agent 1:</p>
<pre># Terminal 1: Start the backend price tracker (waits for signal)
node bubble-price-tracker.cjs --site=app.split.lease

# Terminal 2: Start the browser automation
node proposal-journey-bubble.cjs --site=app.split.lease</pre>
    <div class="proposal__why">
      <strong>Order doesn't matter:</strong> Agent 2 polls for the signal file for up to 10 minutes. You can start them in either order or simultaneously. Agent 2 will patiently wait until Agent 1 creates the listing and writes the signal.
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Resume Mid-Flow</h3>
      <span class="proposal__impact impact--agent1">Agent 1 Only</span>
      <span class="proposal__effort">Skip-to Mode</span>
    </div>
    <p>Skip Phase 1 and start from the guest proposal using an existing listing:</p>
<pre># Skip to Phase 2 using an existing listing
node proposal-journey-bubble.cjs \
  --skip-to=phase2 \
  --listing-url=https://app.split.lease/view-split-lease/173829584...</pre>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Prerequisites</h3>
      <span class="proposal__impact impact--shared">Both Agents</span>
      <span class="proposal__effort">Setup</span>
    </div>
    <ul>
      <li><strong>Node.js</strong> &mdash; v18+ (uses native <code>fetch</code>)</li>
      <li><strong>Playwright</strong> &mdash; <code>npm install playwright</code> (Agent 1 only)</li>
      <li><strong>Bubble API key</strong> &mdash; via <code>--api-key</code>, <code>BUBBLE_API_KEY</code> env, or hardcoded default (Agent 2 only)</li>
      <li><strong>Test accounts</strong> &mdash; host and guest accounts must exist on the target site</li>
      <li><strong>Supabase access</strong> &mdash; anon key is hardcoded for backend verification (Agent 1)</li>
    </ul>
    <div class="proposal__tags">
      <span class="tag">node 18+</span>
      <span class="tag">playwright</span>
      <span class="tag">no other deps</span>
    </div>
  </div>
</div>

<hr>

<!-- SUMMARY -->
<div class="section">
  <div class="section__number">Summary</div>
  <h2>Architecture at a Glance</h2>

  <p><strong>Agent 1</strong> (<code>proposal-journey-bubble.cjs</code>, 1,180 lines) is a Playwright browser automation that drives the full four-phase proposal lifecycle&mdash;listing creation, proposal submission, host counter-offer, and guest acceptance&mdash;while capturing screenshots, video, UI-scraped prices, and Supabase verification data.</p>

  <p><strong>Agent 2</strong> (<code>bubble-price-tracker.cjs</code>, 580 lines) is a headless Bubble Data API poller that runs in parallel, watching for backend data changes at each lifecycle stage. It produces structured diffs and a cross-phase price comparison table.</p>

  <p>Together, they validate that what users see in the browser matches what the Bubble backend stores and what Supabase records&mdash;three independent views of every price, every status change, and every transition in the proposal lifecycle.</p>

  <div class="callout callout--success">
    <div class="callout__title">The key design principle</div>
    <p>Price discrepancies between UI, API, and database are the hardest bugs to catch and the most costly to miss. By running a browser agent and an API agent in parallel against the same transaction, and then cross-referencing with a database query, this test suite catches pricing bugs that any single-surface test would miss entirely.</p>
  </div>
</div>

<hr>

<!-- HOW IT WAS BUILT -->
<div class="section">
  <div class="section__number">How It Was Built</div>
  <h2>From Manual Recording to Autonomous Agents</h2>
  <p class="section__subtitle">The development process combined Playwright's codegen recorder for UI selectors with Claude Code for API integration and agent orchestration.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Step 1: Record the Journey with Playwright Codegen</h3>
      <span class="proposal__impact impact--agent1">Foundation</span>
      <span class="proposal__effort">Manual Recording</span>
    </div>
    <p>The entire process started by manually walking through the proposal journey on app.split.lease while <strong>Playwright's codegen recorder</strong> watched. Running <code>npx playwright codegen app.split.lease</code> opened a browser with an inspector panel that captured every click, every form fill, and every navigation as generated test code in real time.</p>
    <p>The recording session (February 9, 2026) walked through the full flow: host login &rarr; listing wizard &rarr; proposal creation &rarr; counter-offer &rarr; acceptance. Codegen produced the raw selectors&mdash;the exact <code>getByRole</code>, <code>getByText</code>, <code>locator</code>, and <code>selectOption</code> calls that target Bubble's dynamically generated DOM elements.</p>
    <div class="proposal__why">
      <strong>Why codegen first:</strong> Bubble.io generates non-semantic CSS class names (e.g., <code>.cmaRhaT</code>, <code>.cvaAaIi12</code>) and wraps form controls in nested containers that are nearly impossible to guess. Recording the selectors from a live session is the only reliable way to get them right. The codegen output became the ground truth for every UI interaction in Agent 1.
    </div>
    <div class="proposal__tags">
      <span class="tag">npx playwright codegen</span>
      <span class="tag">2026-02-09 recording</span>
      <span class="tag">selector capture</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Step 2: Translate the Recording into Replayable Code</h3>
      <span class="proposal__impact impact--agent1">Agent 1</span>
      <span class="proposal__effort">Script Assembly</span>
    </div>
    <p>The raw codegen output was a flat sequence of actions&mdash;no structure, no error handling, no multi-user flow. The next step was reshaping it into the phased, parameterized script that Agent 1 became:</p>
    <ul>
      <li><strong>Extracted selectors</strong> from the codegen recording and organized them by wizard section (address, features, lease style, pricing, rules, photos)</li>
      <li><strong>Captured Bubble internal values</strong>&mdash;the option values like <code>"1348695171700984260__LOOKUP__1569530159044x216130979074711000"</code> that Bubble's comboboxes use internally. These came directly from the codegen's <code>selectOption()</code> calls</li>
      <li><strong>Split the single recording into four phases</strong> with separate login/logout cycles for host and guest, since codegen records a single continuous session</li>
      <li><strong>Added wait times</strong> calibrated from the recording&mdash;Bubble's workflows need 15&ndash;60 seconds depending on the operation, and these timings were tuned by observing the codegen playback</li>
    </ul>
    <div class="proposal__why">
      <strong>The codegen gave us the "what":</strong> which elements to click, which values to select, which text to type. The script structure&mdash;phases, user switching, screenshot capture, URL extraction&mdash;was built around these recorded interactions as the skeleton.
    </div>
    <div class="proposal__tags">
      <span class="tag">BUBBLE_VALUES</span>
      <span class="tag">phase structure</span>
      <span class="tag">selector mapping</span>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Step 3: Claude Code Built the API &amp; Intelligence Layers</h3>
      <span class="proposal__impact impact--agent2">Agent 2</span>
      <span class="proposal__effort">AI-Assisted</span>
    </div>
    <p>With Agent 1's browser flow working, <strong>Claude Code</strong> was used to design and build the entire backend verification and price tracking layer. Claude Code had access to the stored information from the project&mdash;the Bubble Data API structure, Supabase schema, field names from raw API responses, and the existing Agent 1 codebase&mdash;and used it to construct:</p>
    <ul>
      <li><strong>Agent 2 (bubble-price-tracker.cjs)</strong>&mdash;the complete parallel price tracker, including the Bubble Data API client, field extraction functions for all 17 listing and 22 proposal fields, the snapshot diffing engine, the signal file coordination protocol, and the cross-phase summary report generator</li>
      <li><strong>Backend Observer</strong>&mdash;the Supabase verification system in Agent 1 that queries the database directly and generates field-by-field comparison reports</li>
      <li><strong>Price scraping layer</strong>&mdash;the regex-based price capture functions that Agent 1 uses to extract dollar amounts from Bubble's rendered UI at each phase</li>
      <li><strong>Inter-agent coordination</strong>&mdash;the file-based IPC protocol (signal files, shared output directory, dual termination strategy) that lets both agents run independently while sharing a single run folder</li>
      <li><strong>Resilience patterns</strong>&mdash;the multi-strategy fallbacks for sign-out, URL extraction, API lookups, and modal dismissal that handle Bubble's unpredictable UI state</li>
    </ul>
    <div class="proposal__why">
      <strong>Division of labor:</strong> The human provided the domain knowledge (how Split Lease works, what the proposal flow should look like) and the raw UI selectors (via codegen). Claude Code provided the systems engineering&mdash;API integration, data diffing, agent coordination, error handling, and the output structure that makes the test results actionable.
    </div>
    <div class="proposal__tags">
      <span class="tag">Claude Code</span>
      <span class="tag">Bubble Data API</span>
      <span class="tag">Supabase integration</span>
      <span class="tag">agent coordination</span>
    </div>
  </div>

  <div class="diagram">
    <pre>
  DEVELOPMENT PIPELINE
  ════════════════════════════════════════════════════════════════

  ┌─────────────────────┐
  │  1. PLAYWRIGHT       │   Human walks through app.split.lease
  │     CODEGEN          │   while recorder captures every action
  │                      │
  │  npx playwright      │   Output: raw selectors, option values,
  │  codegen             │   navigation paths, form interactions
  └──────────┬──────────┘
             │
             │  Selectors + Bubble internal values
             │
  ┌──────────▼──────────┐
  │  2. SCRIPT           │   Organize codegen output into phases
  │     ASSEMBLY         │   Add user switching, parameterization,
  │                      │   wait times, screenshot points
  │  Human + codegen     │
  │  output              │   Output: Agent 1 skeleton with all
  └──────────┬──────────┘   UI interactions working
             │
             │  Working browser flow + stored API data
             │
  ┌──────────▼──────────┐
  │  3. CLAUDE CODE      │   Reads project context:
  │     BUILDS THE       │   - Bubble API field names from responses
  │     REST             │   - Supabase schema from existing queries
  │                      │   - Agent 1 code for coordination design
  │  AI-assisted         │
  │  engineering         │   Output: Agent 2, Backend Observer,
  └─────────────────────┘   price scraping, IPC, error handling
    </pre>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>See It in Action</h3>
      <span class="proposal__impact impact--shared">Demo</span>
      <span class="proposal__effort">Video Recording</span>
    </div>
    <p>Watch Playwright autonomously drive through the full proposal journey&mdash;logging in, filling the listing wizard, switching users, creating proposals, countering terms, and accepting&mdash;all from the codegen-sourced selectors running against live Bubble UI:</p>
    <div style="position: relative; padding-bottom: 56.25%; height: 0; margin: 16px 0; border-radius: 10px; overflow: hidden; border: 1px solid var(--border);">
      <iframe src="https://www.loom.com/embed/8a4e037a06da49d7b47f2bc098cb3a50" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe>
    </div>
    <div class="proposal__why">
      <strong>What you're seeing:</strong> Agent 1 replaying the recorded codegen path autonomously. Every click, form fill, and navigation was originally captured from a manual walkthrough, then assembled into the four-phase script. The browser runs headed (visible) with 300ms slow-motion so each action is observable.
    </div>
    <div class="proposal__tags">
      <span class="tag">Loom recording</span>
      <span class="tag">headed browser</span>
      <span class="tag">slowMo: 300</span>
    </div>
  </div>

  <div class="callout callout--insight">
    <div class="callout__title">The pattern: Record &rarr; Replicate &rarr; Augment</div>
    <p>This three-step approach&mdash;record the user journey with codegen, replicate it as structured automation code, then augment with AI-built API and verification layers&mdash;is repeatable for any Bubble.io application. The codegen recording handles the hardest part (Bubble's opaque selectors), the human shapes the flow, and Claude Code builds the intelligence layer that turns a simple replay into a multi-surface verification system.</p>
  </div>
</div>


<hr>

<!-- SOURCE CODE -->
<div class="section">
  <div class="section__number">Source Code</div>
  <h2>Full Script Source</h2>
  <p class="section__subtitle">Both agent scripts in full. Click to expand, then copy to clipboard.</p>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Agent 1: proposal-journey-bubble.cjs</h3>
      <span class="proposal__impact impact--agent1">1,180 lines</span>
      <span class="proposal__effort">Playwright</span>
    </div>
    <p>The browser automation agent. Drives the full host/guest proposal lifecycle, captures screenshots and video, scrapes UI prices, and verifies against Supabase.</p>
    <button class="code-toggle" aria-expanded="false" onclick="toggleCode(this)">
      <span class="arrow">&#9654;</span> Show source code
    </button>
    <div class="code-collapse">
      <div class="code-section">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code id="agent1-code">/**
 * Autonomous Playwright Script: Full Listing + Proposal Flow on app.split.lease (Bubble)
 *
 * Phase 1: Host creates listing (login → wizard → submit)
 * Phase 2: Guest creates proposal on that listing
 * Phase 3: Host counters the proposal (edits terms)
 * Phase 4: Guest accepts host's counter-terms
 *
 * Selectors sourced from Playwright codegen recording (2026-02-09).
 */

const { chromium } = require('playwright');
const path = require('path');
const fs = require('fs');
const zlib = require('zlib');

// ============================================================================
// Site Profiles
// ============================================================================

const SITE_PROFILES = {
  'app.split.lease': {
    baseURL: 'https://app.split.lease',
    host: {
      email: 'rodtesthost2@test.com',
      password: 'eCom@2024',
    },
    guest: {
      email: 'splitleasetesting@test.com',
      password: 'eCom@2024',
    },
  },
  'split.lease': {
    baseURL: 'https://split.lease',
    host: {
      email: 'rodtesthost@test.com',
      password: 'eCom@2024',
    },
    guest: {
      email: 'splitleasetesting@test.com',
      password: 'eCom@2024',
    },
  },
};

// Parse --site arg (default: app.split.lease)
const siteArg = process.argv.find((a) =&gt; a.startsWith('--site='));
const siteName = siteArg ? siteArg.split('=')[1] : 'app.split.lease';
const siteProfile = SITE_PROFILES[siteName];

// Parse --skip-to=phase2 --listing-url=&lt;url&gt; to skip Phase 1
const skipToArg = process.argv.find((a) =&gt; a.startsWith('--skip-to='));
const skipToPhase = skipToArg ? skipToArg.split('=')[1].toLowerCase() : null;
const listingURLArg = process.argv.find((a) =&gt; a.startsWith('--listing-url='));
const listingURLFromCLI = listingURLArg ? listingURLArg.split('=').slice(1).join('=') : null;

if (skipToPhase &amp;&amp; !['phase2', 'phase3', 'phase4'].includes(skipToPhase)) {
  console.error(`Unknown --skip-to value: ${skipToPhase}. Use: phase2, phase3, phase4`);
  process.exit(1);
}
if (skipToPhase &amp;&amp; !listingURLFromCLI) {
  console.error('--skip-to requires --listing-url=&lt;url&gt; to know which listing to use');
  process.exit(1);
}

if (!siteProfile) {
  console.error(`Unknown site: ${siteName}. Available: ${Object.keys(SITE_PROFILES).join(', ')}`);
  process.exit(1);
}

console.log(`\n=== Target: ${siteName} (${siteProfile.baseURL}) ===\n`);

// ============================================================================
// Configuration
// ============================================================================

const CONFIG = {
  baseURL: siteProfile.baseURL,
  credentials: siteProfile.host, // backward compat — host is the initial user
  host: siteProfile.host,
  guest: siteProfile.guest,
  listing: {
    title: 'PW Test ' + new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '').slice(5),
    typeOfSpaceLabel: 'Private Room',
    bedroomsLabel: 'Studio',
    kitchenLabel: 'Full Kitchen',
    parkingLabel: 'Street Parking',
    bathroomsLabel: '2',
    address: '234 W 42nd St, New York',
    leaseStyle: 'Nights-of-the-week',
  },
  proposal: {
    daysSelected: '1, 2, 3, 4, 5, 6, 7', // all days (Mon-Sun)
    initialDuration: '6 weeks',
    counterDuration: '"10_weeks"', // Bubble internal value — host changes to 10 weeks
    counterDurationLabel: '10 weeks',
  },
  slowMo: 300,
  navigationTimeout: 60000,
  actionTimeout: 30000,
};

// Bubble internal option values — captured from Playwright codegen
const BUBBLE_VALUES = {
  address: {
    typeOfSpace: '"1348695171700984260__LOOKUP__1569530159044x216130979074711000"',
    bedrooms: '"studio"',
    kitchen: '"full_kitchen"',
    parking: '"1348695171700984260__LOOKUP__1642428637379x970678957586007000"',
    bathrooms: '2',
  },
  rules: {
    cancellationPolicy: '"1348695171700984260__LOOKUP__1665431440883x653177548350901500"',
    numberOfGuests: '1',
    secureStorage: '"1348695171700984260__LOOKUP__1606866759190x694414586166435100"',
  },
  proposal: {
    duration16Weeks: '"16_weeks"',
    duration10Weeks: '"10_weeks"',
  },
};

// ============================================================================
// Directory Setup
// ============================================================================

const safeSiteName = siteName.replace(/\./g, '-');
const runTimestamp = new Date()
  .toISOString()
  .replace(/T/, '_')
  .replace(/:/g, '-')
  .replace(/\.\d+Z$/, '');

const siteDir = path.join(__dirname, 'recordings', safeSiteName);
const recordingsDir = path.join(siteDir, runTimestamp);
const screenshotsDir = path.join(recordingsDir, 'screenshots');
const testImagesDir = path.join(recordingsDir, 'test-images');

if (!fs.existsSync(recordingsDir)) fs.mkdirSync(recordingsDir, { recursive: true });
if (!fs.existsSync(screenshotsDir)) fs.mkdirSync(screenshotsDir, { recursive: true });
if (!fs.existsSync(testImagesDir)) fs.mkdirSync(testImagesDir, { recursive: true });

const latestPointerPath = path.join(siteDir, 'latest.txt');
fs.writeFileSync(latestPointerPath, runTimestamp);

// Price log — captures prices at each phase for the price tracker
const priceLog = [];
const priceLogPath = path.join(recordingsDir, 'price-log.json');
// Signal file for Agent 2 (parallel price tracker) — written after listing creation
const signalFilePath = path.join(recordingsDir, 'listing-signal.json');

function logPrice(phase, label, data) {
  const entry = {
    timestamp: new Date().toISOString(),
    phase,
    label,
    ...data,
  };
  priceLog.push(entry);
  fs.writeFileSync(priceLogPath, JSON.stringify(priceLog, null, 2));
  log('PRICE', `[${phase}] ${label}: ${JSON.stringify(data)}`);
}

// Helper to scrape dollar amounts from visible text on the page
async function scrapePrices(page, selectors) {
  const prices = {};
  for (const [key, fn] of Object.entries(selectors)) {
    try {
      prices[key] = await fn(page);
    } catch (e) {
      prices[key] = null;
    }
  }
  return prices;
}

console.log(`[RUN] ${runTimestamp}  →  ${recordingsDir}\n`);

// ============================================================================
// Backend Observer - Verifies listing in Supabase
// ============================================================================

const SUPABASE_URL = 'https://qcfifybkaddcoimjroca.supabase.co';
const SUPABASE_ANON_KEY =
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFjZmlmeWJrYWRkY29pbWpyb2NhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk0NzU0MDUsImV4cCI6MjA3NTA1MTQwNX0.glGwHxds0PzVLF1Y8VBGX0jYz3zrLsgE9KAWWwkYms8';

async function querySupabaseListing(hostEmail, listingName) {
  log('OBSERVER', 'Querying Supabase for listing...');
  const url = new URL(`${SUPABASE_URL}/rest/v1/listing`);
  url.searchParams.set('select', '*');
  url.searchParams.set('order', 'id.desc');
  url.searchParams.set('limit', '10');

  try {
    const response = await fetch(url.toString(), {
      headers: {
        apikey: SUPABASE_ANON_KEY,
        Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      log('OBSERVER', `Supabase query failed: ${response.status} - ${errorText}`);
      return null;
    }

    const data = await response.json();
    if (data.length === 0) {
      log('OBSERVER', 'No listing found in Supabase');
      return null;
    }

    const record = data.find(r =&gt;
      (r.name === listingName || r.Name === listingName) &amp;&amp;
      (r.host_email === hostEmail || r['Host email'] === hostEmail)
    );

    if (record) {
      log('OBSERVER', `Supabase listing found: id=${record.id}`);
      return record;
    }

    log('OBSERVER', 'Listing not found in recent records');
    return data[0];
  } catch (error) {
    log('OBSERVER', `Supabase query error: ${error.message}`);
    return null;
  }
}

function generateVerificationReport(supabaseRecord) {
  const expectedMap = {
    'Listing Name': { supabaseColumn: 'Name', expected: CONFIG.listing.title },
    'Type of Space': { supabaseColumn: 'Features - Type of Space', expected: CONFIG.listing.typeOfSpaceLabel, isForeignKey: true },
    'Bedrooms': { supabaseColumn: 'Features - Qty Bedrooms', expected: CONFIG.listing.bedroomsLabel },
    'Kitchen Type': { supabaseColumn: 'Kitchen Type', expected: CONFIG.listing.kitchenLabel },
    'Parking Type': { supabaseColumn: 'Features - Parking type', expected: CONFIG.listing.parkingLabel, isForeignKey: true },
    'Bathrooms': { supabaseColumn: 'Features - Qty Bathrooms', expected: Number(CONFIG.listing.bathroomsLabel) },
    'Rental Type': { supabaseColumn: 'rental type', expected: 'Nightly' },
    'Status': { supabaseColumn: 'Active', expected: false },
  };

  const report = {
    run: runTimestamp,
    timestamp: new Date().toISOString(),
    site: siteName,
    supabaseFound: !!supabaseRecord,
    supabaseListingId: supabaseRecord?.id || null,
    fields: [],
    summary: { total: 0, match: 0, mismatch: 0 },
  };

  for (const [label, spec] of Object.entries(expectedMap)) {
    const supabaseValue = supabaseRecord
      ? (supabaseRecord[spec.supabaseColumn] || supabaseRecord[spec.supabaseColumn.toLowerCase()] || supabaseRecord[spec.supabaseColumn.replace(/ /g, '_').toLowerCase()])
      : undefined;
    let isMatch;
    if (spec.isForeignKey) {
      isMatch = supabaseValue != null &amp;&amp; supabaseValue !== '';
    } else {
      isMatch = compareValues(spec.expected, supabaseValue);
    }

    report.fields.push({
      field: label,
      expected: spec.expected,
      actual: supabaseValue,
      result: isMatch ? 'MATCH' : 'MISMATCH',
      isForeignKey: spec.isForeignKey || false,
    });
    report.summary.total++;
    if (isMatch) report.summary.match++;
    else report.summary.mismatch++;
  }

  return report;
}

function compareValues(expected, actual) {
  if (expected === actual) return true;
  if (expected == null &amp;&amp; actual == null) return true;
  if (expected == null || actual == null) return false;
  if (typeof expected === 'number' &amp;&amp; typeof actual === 'string') return expected === Number(actual);
  if (typeof expected === 'string' &amp;&amp; typeof actual === 'number') return Number(expected) === actual;
  if (typeof expected === 'string' &amp;&amp; typeof actual === 'string') return expected.trim() === actual.trim();
  return JSON.stringify(expected) === JSON.stringify(actual);
}

function printVerificationReport(report) {
  log('OBSERVER', '');
  log('OBSERVER', '======================================================');
  log('OBSERVER', '        BACKEND OBSERVER - VERIFICATION REPORT         ');
  log('OBSERVER', '======================================================');
  log('OBSERVER', '');
  log('OBSERVER', `Site:              ${report.site}`);
  log('OBSERVER', `Timestamp:         ${report.timestamp}`);
  log('OBSERVER', `Supabase Found:    ${report.supabaseFound ? 'YES' : 'NO'}`);
  log('OBSERVER', `Supabase ID:       ${report.supabaseListingId || 'N/A'}`);
  log('OBSERVER', '');

  for (const field of report.fields) {
    const icon = field.result === 'MATCH' ? '[OK]' : '[!!]';
    const fk = field.isForeignKey ? ' (FK)' : '';
    log('OBSERVER', `  ${icon} ${field.field}${fk}: expected="${field.expected}" actual="${field.actual}"`);
  }

  log('OBSERVER', '');
  log('OBSERVER', `Summary: ${report.summary.total} fields - ${report.summary.match} match, ${report.summary.mismatch} mismatch`);
  log('OBSERVER', '');
}

async function runBackendObserver() {
  log('OBSERVER', '========== BACKEND OBSERVER ==========');

  const supabaseRecord = await querySupabaseListing(
    CONFIG.host.email,
    CONFIG.listing.title
  );

  const report = generateVerificationReport(supabaseRecord);
  printVerificationReport(report);

  const fullReport = { ...report, rawData: { supabase: supabaseRecord } };
  const reportPath = path.join(recordingsDir, 'verification-report.json');
  fs.writeFileSync(reportPath, JSON.stringify(fullReport, null, 2));
  log('OBSERVER', `Full report saved to: ${reportPath}`);

  return report;
}

// ============================================================================
// Helper Functions
// ============================================================================

function log(step, message) {
  const timestamp = new Date().toLocaleTimeString();
  console.log(`[${timestamp}] [${step}] ${message}`);
}

async function screenshot(page, name) {
  const filepath = path.join(screenshotsDir, `${name}.png`);
  await page.screenshot({ path: filepath, fullPage: false });
  log('SCREENSHOT', `Saved: ${name}.png`);
}

/**
 * Login as a specific user. Assumes we're on the homepage (signed out).
 * Uses exact codegen selectors from the Bubble auth modal.
 */
async function loginAs(page, email, password, label) {
  log(label, `Logging in as ${email}...`);

  await page.getByText('Sign In | Sign Up').click();
  await page.waitForTimeout(2000);

  await page.getByRole('button', { name: 'Log into my account' }).click();
  await page.waitForTimeout(1500);

  await page.getByRole('textbox', { name: 'example@example.com*' }).click();
  await page.getByRole('textbox', { name: 'example@example.com*' }).fill(email);
  await page.getByRole('textbox', { name: 'Password *' }).click();
  await page.getByRole('textbox', { name: 'Password *' }).fill(password);

  await page.getByRole('button', { name: 'Login' }).click();
  log(label, 'Waiting for login to complete (15s)...');
  await page.waitForTimeout(15000);
}

/**
 * Sign out the current user. Handles overlay dismissal.
 * After sign-out, user lands on the homepage.
 */
async function signOut(page, label) {
  log(label, 'Signing out...');

  // Dismiss any blocking modals first (suggestions, confirmations, etc.)
  for (const dismissText of ['Ignore', 'Close', 'Cancel', 'No Thanks']) {
    try {
      const btn = page.getByRole('button', { name: dismissText });
      if (await btn.isVisible({ timeout: 1000 })) {
        await btn.click();
        await page.waitForTimeout(1000);
        log(label, `Dismissed modal via "${dismissText}"`);
      }
    } catch (e) { /* not found — continue */ }
  }

  // Dismiss any greyout overlays
  try {
    const greyout = page.locator('.greyout').first();
    if (await greyout.isVisible({ timeout: 1000 })) {
      await greyout.click();
      await page.waitForTimeout(1000);
    }
  } catch (e) { /* no overlay */ }

  // Try to open avatar dropdown and click Sign Out
  let signedOut = false;

  // Strategy 1: Avatar dropdown → Sign Out
  try {
    await page.locator('.bubble-element.Image.cmaRhaT &gt; img').click({ timeout: 5000 });
    await page.waitForTimeout(1500);
    await page.getByText('Sign Out').click({ timeout: 5000 });
    signedOut = true;
  } catch (e) {
    log(label, 'Avatar dropdown failed — trying fallback...');
  }

  // Strategy 2: Navigate to homepage first, then avatar → Sign Out
  if (!signedOut) {
    try {
      await page.goto(CONFIG.baseURL, { waitUntil: 'domcontentloaded' });
      await page.waitForTimeout(5000);
      await page.locator('.bubble-element.Image.cmaRhaT &gt; img').click({ timeout: 10000 });
      await page.waitForTimeout(1500);
      await page.getByText('Sign Out').click({ timeout: 5000 });
      signedOut = true;
    } catch (e) {
      log(label, 'Homepage sign-out also failed — trying direct text click...');
    }
  }

  // Strategy 3: Just find "Sign Out" text anywhere on page
  if (!signedOut) {
    await page.getByText('Sign Out').click();
  }

  log(label, 'Waiting for sign-out to complete (10s)...');
  await page.waitForTimeout(10000);
}

/**
 * Extract the listing view URL from the manage listing page.
 * Uses clipboard interception via Copy Listing Link button.
 * Falls back to searching for view-split-lease links in the page.
 */
async function extractListingURL(page, label) {
  log(label, 'Extracting listing URL...');

  // Strategy 1: Intercept clipboard write and click "Copy Listing Link"
  await page.evaluate(() =&gt; {
    window.__clipboardText = '';
    const original = navigator.clipboard.writeText.bind(navigator.clipboard);
    navigator.clipboard.writeText = async (text) =&gt; {
      window.__clipboardText = text;
      return original(text);
    };
  });

  try {
    await page.getByText('Copy Listing Link').click();
    await page.waitForTimeout(2000);
    const clipboardURL = await page.evaluate(() =&gt; window.__clipboardText);
    if (clipboardURL &amp;&amp; clipboardURL.includes('view-split-lease')) {
      log(label, `Got listing URL from clipboard: ${clipboardURL}`);
      return clipboardURL;
    }
  } catch (e) {
    log(label, 'Copy Listing Link click failed, trying fallback...');
  }

  // Strategy 2: Find a link with view-split-lease in the page
  try {
    const href = await page.locator('a[href*="view-split-lease"]').first().getAttribute('href');
    if (href) {
      const fullURL = href.startsWith('http') ? href : `${CONFIG.baseURL}${href}`;
      log(label, `Got listing URL from page link: ${fullURL}`);
      return fullURL;
    }
  } catch (e) {
    log(label, 'No view-split-lease link found in page');
  }

  // Strategy 3: Extract from current URL if it contains a listing identifier
  const currentURL = page.url();
  log(label, `Current URL: ${currentURL}`);

  // Try to find the listing ID in the URL path
  const idMatch = currentURL.match(/(\d{10,}x\d{10,})/);
  if (idMatch) {
    const listingURL = `${CONFIG.baseURL}/view-split-lease/${idMatch[1]}`;
    log(label, `Constructed listing URL from page URL: ${listingURL}`);
    return listingURL;
  }

  log(label, 'WARNING: Could not extract listing URL — proposal flow may fail');
  return null;
}

// ============================================================================
// PNG Test Image Generation
// ============================================================================

function generateTestImages(count) {
  const colors = [
    [255, 0, 0],   // red
    [0, 128, 0],   // green
    [0, 0, 255],   // blue
  ];
  const paths = [];

  for (let i = 0; i &lt; count; i++) {
    const filePath = path.join(testImagesDir, `test-image-${i + 1}.png`);
    const [r, g, b] = colors[i % colors.length];
    const width = 10;
    const height = 10;

    const signature = Buffer.from([137, 80, 78, 71, 13, 10, 26, 10]);

    const ihdrData = Buffer.alloc(13);
    ihdrData.writeUInt32BE(width, 0);
    ihdrData.writeUInt32BE(height, 4);
    ihdrData[8] = 8;  ihdrData[9] = 2;
    ihdrData[10] = 0; ihdrData[11] = 0; ihdrData[12] = 0;
    const ihdr = createPNGChunk('IHDR', ihdrData);

    const rawRow = Buffer.alloc(1 + width * 3);
    rawRow[0] = 0;
    for (let x = 0; x &lt; width; x++) {
      rawRow[1 + x * 3] = r;
      rawRow[2 + x * 3] = g;
      rawRow[3 + x * 3] = b;
    }
    const rawData = Buffer.concat(Array(height).fill(rawRow));
    const compressed = zlib.deflateSync(rawData);
    const idat = createPNGChunk('IDAT', compressed);
    const iend = createPNGChunk('IEND', Buffer.alloc(0));

    fs.writeFileSync(filePath, Buffer.concat([signature, ihdr, idat, iend]));
    paths.push(filePath);
    log('INIT', `Generated test image: ${filePath}`);
  }
  return paths;
}

function createPNGChunk(type, data) {
  const length = Buffer.alloc(4);
  length.writeUInt32BE(data.length, 0);
  const typeBuffer = Buffer.from(type, 'ascii');
  const crc = crc32(Buffer.concat([typeBuffer, data]));
  const crcBuffer = Buffer.alloc(4);
  crcBuffer.writeUInt32BE(crc &gt;&gt;&gt; 0, 0);
  return Buffer.concat([length, typeBuffer, data, crcBuffer]);
}

function crc32(buf) {
  let crc = 0xFFFFFFFF;
  for (let i = 0; i &lt; buf.length; i++) {
    crc ^= buf[i];
    for (let j = 0; j &lt; 8; j++) {
      crc = (crc &gt;&gt;&gt; 1) ^ (crc &amp; 1 ? 0xEDB88320 : 0);
    }
  }
  return ~crc;
}

// ============================================================================
// Main Script
// ============================================================================

(async () =&gt; {
  log('INIT', 'Launching browser with video recording...');

  const testImagePaths = generateTestImages(3);

  const browser = await chromium.launch({
    headless: false,
    slowMo: CONFIG.slowMo,
  });

  const context = await browser.newContext({
    recordVideo: {
      dir: recordingsDir,
      size: { width: 1280, height: 720 },
    },
    viewport: { width: 1280, height: 720 },
    ignoreHTTPSErrors: true,
  });

  // Grant clipboard permissions for extracting listing URL
  await context.grantPermissions(['clipboard-read', 'clipboard-write']);

  const page = await context.newPage();
  page.setDefaultTimeout(CONFIG.actionTimeout);
  page.setDefaultNavigationTimeout(CONFIG.navigationTimeout);

  // Track the listing URL for the proposal flow
  let listingViewURL = listingURLFromCLI || null;

  try {
    // ====================================================================
    //  PHASE 1: HOST CREATES LISTING
    // ====================================================================
    if (skipToPhase) {
      log('PHASE 1', `========== SKIPPED (--skip-to=${skipToPhase}) ==========`);
      log('PHASE 1', `Using listing URL: ${listingViewURL}`);
      // Navigate to homepage so loginAs can find the Sign In button
      await page.goto(CONFIG.baseURL, { waitUntil: 'domcontentloaded' });
      await page.waitForTimeout(5000);
    } else {
    log('PHASE 1', '========== HOST CREATES LISTING ==========');

    // ========================================================================
    // STEP 1: Navigate to homepage
    // ========================================================================
    log('STEP 1', 'Navigating to homepage...');
    await page.goto(CONFIG.baseURL, { waitUntil: 'domcontentloaded' });
    await page.waitForTimeout(5000);
    await screenshot(page, '01-homepage');

    // ========================================================================
    // STEP 2: Host login
    // ========================================================================
    log('STEP 2', 'Host logging in...');
    await loginAs(page, CONFIG.host.email, CONFIG.host.password, 'STEP 2');
    await screenshot(page, '02-host-logged-in');

    // ========================================================================
    // STEP 3: Navigate to Host Dashboard
    // ========================================================================
    log('STEP 3', 'Opening avatar dropdown...');
    await page.locator('.bubble-element.Image.cmaRhaT &gt; img').click();
    await page.waitForTimeout(1500);

    log('STEP 3', 'Clicking Listings &amp; Proposals...');
    await page.getByText('Listings &amp; Proposals').click();
    log('STEP 3', 'Waiting for dashboard to load (30s)...');
    await page.waitForTimeout(30000);
    await screenshot(page, '03-host-dashboard');

    // ========================================================================
    // STEP 4: Create New Listing modal
    // ========================================================================
    log('STEP 4', 'Dismissing any greyout overlays...');
    try {
      const greyout = page.locator('.greyout').first();
      if (await greyout.isVisible({ timeout: 3000 })) {
        await greyout.click();
        await page.waitForTimeout(1500);
        log('STEP 4', 'Dismissed greyout overlay');
      }
    } catch (e) { /* no overlay */ }

    log('STEP 4', 'Clicking + Create New Listing...');
    await page.getByRole('button', { name: '+ Create New Listing' }).click({ force: true });
    await page.waitForTimeout(3000);

    log('STEP 4', 'Filling listing title...');
    await page.locator('#idid').getByRole('textbox').click();
    await page.locator('#idid').getByRole('textbox').fill(CONFIG.listing.title);
    await page.waitForTimeout(500);

    log('STEP 4', 'Clicking Create New...');
    await page.getByRole('button', { name: 'Create New', exact: true }).click();
    log('STEP 4', 'Waiting for wizard to load (60s)...');
    await page.waitForTimeout(60000);
    await screenshot(page, '04-wizard-loaded');

    // ========================================================================
    // STEP 5: Section 1 - Address (Space Snapshot)
    // ========================================================================
    log('STEP 5', 'Filling Address section...');

    await page.getByRole('combobox').first().selectOption(BUBBLE_VALUES.address.typeOfSpace);
    await page.waitForTimeout(500);
    await page.getByRole('combobox').nth(1).selectOption(BUBBLE_VALUES.address.bedrooms);
    await page.waitForTimeout(500);
    await page.getByRole('combobox').nth(2).selectOption(BUBBLE_VALUES.address.kitchen);
    await page.waitForTimeout(500);
    // Index 3 = Beds (using default)
    await page.getByRole('combobox').nth(4).selectOption(BUBBLE_VALUES.address.parking);
    await page.waitForTimeout(500);
    await page.getByRole('combobox').nth(5).selectOption(BUBBLE_VALUES.address.bathrooms);
    await page.waitForTimeout(500);

    log('STEP 5', 'Filling address with autocomplete...');
    await page.getByRole('textbox', { name: 'Main St.' }).click();
    await page.getByRole('textbox', { name: 'Main St.' }).fill(CONFIG.listing.address);
    await page.waitForTimeout(5000);

    try {
      const pacItem = page.locator('.pac-container .pac-item').first();
      await pacItem.waitFor({ state: 'visible', timeout: 8000 });
      await pacItem.click();
      log('STEP 5', 'Clicked autocomplete suggestion');
    } catch (e) {
      log('STEP 5', 'No autocomplete — pressing Enter');
      await page.getByRole('textbox', { name: 'Main St.' }).press('Enter');
    }
    await page.waitForTimeout(3000);
    await screenshot(page, '05-address-filled');

    log('STEP 5', 'Clicking Next...');
    await page.getByRole('button', { name: 'Next' }).click();
    await page.waitForTimeout(15000);

    // ========================================================================
    // STEP 6: Section 2 - Features
    // ========================================================================
    log('STEP 6', 'Filling Features section...');
    await page.getByText('load common').first().click();
    await page.waitForTimeout(2000);
    try {
      await page.getByText('load common', { exact: true }).click();
      await page.waitForTimeout(2000);
    } catch (e) { /* already loaded */ }

    await page.getByText('load template').first().click();
    await page.waitForTimeout(2000);
    await page.getByRole('button', { name: 'Save' }).click();
    await page.waitForTimeout(3000);

    log('STEP 6', 'Clicking Next...');
    await page.getByRole('button', { name: 'Next' }).click();
    await page.waitForTimeout(15000);

    // ========================================================================
    // STEP 7: Section 3 - Lease Styles
    // ========================================================================
    log('STEP 7', 'Selecting Nights-of-the-week...');
    await page.getByText('Nights-of-the-week').click();
    await page.waitForTimeout(2000);

    log('STEP 7', 'Clicking Next...');
    await page.getByRole('button', { name: 'Next' }).click();
    await page.waitForTimeout(15000);

    // ========================================================================
    // STEP 8: Section 4 - Pricing (defaults)
    // ========================================================================
    log('STEP 8', 'Pricing — using defaults...');
    await page.getByRole('button', { name: 'Next' }).click();
    await page.waitForTimeout(15000);

    // ========================================================================
    // STEP 9: Section 5 - Rules
    // ========================================================================
    log('STEP 9', 'Filling Rules section...');
    await page.getByRole('combobox').first().selectOption(BUBBLE_VALUES.rules.cancellationPolicy);
    await page.waitForTimeout(500);
    await page.getByRole('combobox').nth(2).selectOption(BUBBLE_VALUES.rules.numberOfGuests);
    await page.waitForTimeout(500);
    await page.getByRole('combobox').nth(5).selectOption(BUBBLE_VALUES.rules.secureStorage);
    await page.waitForTimeout(500);

    log('STEP 9', 'Clicking Next...');
    await page.getByRole('button', { name: 'Next' }).click();
    await page.waitForTimeout(15000);

    // ========================================================================
    // STEP 10: Section 6 - Photos
    // ========================================================================
    log('STEP 10', 'Uploading photos...');
    await page.getByRole('button', { name: 'Upload Photos' }).click();
    await page.waitForTimeout(3000);

    const fileInput = page.locator('input[type="file"]').first();
    try {
      await fileInput.setInputFiles(testImagePaths);
    } catch (e) {
      await page.locator('.dz-default').click();
      await page.waitForTimeout(1000);
      await fileInput.setInputFiles(testImagePaths);
    }
    await page.waitForTimeout(5000);

    await page.getByRole('button', { name: 'Submit Images' }).click();
    await page.waitForTimeout(15000);

    // ========================================================================
    // STEP 11: Submit Listing
    // ========================================================================
    log('STEP 11', 'Submitting listing...');
    await page.getByRole('button', { name: 'Submit Listing' }).click();
    await page.waitForTimeout(10000);
    await screenshot(page, '06-listing-submitted');

    // ========================================================================
    // STEP 12: Manage Listing + Extract URL
    // ========================================================================
    log('STEP 12', 'Clicking Manage listing...');
    try {
      await page.getByRole('button', { name: 'Manage listing' }).click();
      await page.waitForTimeout(10000);
    } catch (e) {
      log('STEP 12', 'Manage listing button not found — continuing');
    }

    // Close the "Title and Description Suggestions" modal via the empty button
    // (reference script line 47: #EditListingDetails has an empty-text close button)
    log('STEP 12', 'Closing suggestions modal...');
    try {
      await page.locator('#EditListingDetails').getByRole('button').filter({ hasText: /^$/ }).click();
      log('STEP 12', 'Closed modal via #EditListingDetails button');
      await page.waitForTimeout(2000);
    } catch (e) {
      log('STEP 12', 'EditListingDetails button not found — continuing');
    }

    await screenshot(page, '07-manage-listing');

    // Extract listing URL via Copy Listing Link (reference line 48)
    log('STEP 12', 'Clicking Copy Listing Link...');
    try {
      await page.getByText('Copy Listing Link').click();
      await page.waitForTimeout(2000);
      // Read from clipboard
      const clipboardURL = await page.evaluate(() =&gt; navigator.clipboard.readText()).catch(() =&gt; '');
      if (clipboardURL &amp;&amp; clipboardURL.includes('view-split-lease')) {
        listingViewURL = clipboardURL;
        log('STEP 12', `Got listing URL from clipboard: ${listingViewURL}`);
      }
    } catch (e) {
      log('STEP 12', 'Copy Listing Link failed');
    }

    // Fallback: extract from page URL
    if (!listingViewURL) {
      const currentURL = page.url();
      const idMatch = currentURL.match(/(\d{10,}x\d{10,})/);
      if (idMatch) {
        listingViewURL = `${CONFIG.baseURL}/view-split-lease/${idMatch[1]}`;
        log('STEP 12', `Constructed listing URL from page URL: ${listingViewURL}`);
      }
    }
    log('STEP 12', `Listing URL: ${listingViewURL || 'NOT FOUND'}`);

    // Write signal file for Agent 2 (parallel price tracker)
    if (listingViewURL) {
      const listingId = listingViewURL.split('/').pop().split('?')[0];
      const signal = {
        listingId,
        listingURL: listingViewURL,
        listingTitle: CONFIG.listing.title,
        runDir: recordingsDir,
        timestamp: new Date().toISOString(),
      };
      fs.writeFileSync(signalFilePath, JSON.stringify(signal, null, 2));
      log('STEP 12', `Signal file written for price tracker: ${signalFilePath}`);
    }

    // ========================================================================
    // STEP 13: Host signs out (reference lines 49-50)
    // ========================================================================
    log('STEP 13', 'Signing out host...');
    await page.locator('.bubble-element.Image.cmaRhaT &gt; img').click();
    await page.waitForTimeout(1500);
    await page.getByText('Sign Out').click();
    await page.waitForTimeout(10000);
    await screenshot(page, '08-host-signed-out');

    log('PHASE 1', '========== LISTING CREATION COMPLETE ==========');
    } // end of Phase 1 (else branch of skipToPhase check)

    // ====================================================================
    //  PHASE 2: GUEST CREATES PROPOSAL
    // ====================================================================
    log('PHASE 2', '========== GUEST CREATES PROPOSAL ==========');

    if (!listingViewURL) {
      log('PHASE 2', 'SKIPPING — no listing URL was captured');
    } else {
      // ======================================================================
      // STEP 14: Guest signs in (reference lines 52-61)
      // ======================================================================
      await loginAs(page, CONFIG.guest.email, CONFIG.guest.password, 'STEP 14');
      await screenshot(page, '09-guest-logged-in');

      // ======================================================================
      // STEP 15: Guest navigates to listing and creates proposal
      // (reference lines 62-66)
      // ======================================================================
      log('STEP 15', 'Navigating to listing page...');
      const listingPageURL = `${listingViewURL}?days-selected=${encodeURIComponent(CONFIG.proposal.daysSelected)}&amp;duration=${encodeURIComponent(CONFIG.proposal.initialDuration)}`;
      await page.goto(listingPageURL, { waitUntil: 'domcontentloaded' });
      log('STEP 15', 'Waiting for listing page to load (30s)...');
      await page.waitForTimeout(30000);
      await screenshot(page, '10-listing-page');

      // PRICE CAPTURE: Listing page prices
      const listingPrices = await scrapePrices(page, {
        nightlyRate: async (p) =&gt; {
          const el = p.locator('text=/\\$[\\d,.]+\\s*\\/\\s*night/i').first();
          return (await el.textContent({ timeout: 5000 })).trim();
        },
        fourWeekRent: async (p) =&gt; {
          const el = p.locator('text=/4-Week Rent.*\\$[\\d,.]+/i').first();
          return (await el.textContent({ timeout: 5000 })).trim();
        },
      });
      logPrice('LISTING', 'Listing page prices', listingPrices);

      // Change duration to 16 weeks (reference line 64)
      log('STEP 15', 'Setting duration to 16 weeks...');
      try {
        await page.getByRole('combobox').selectOption(BUBBLE_VALUES.proposal.duration16Weeks);
        await page.waitForTimeout(2000);
      } catch (e) {
        log('STEP 15', 'Duration combobox not found — using URL default');
      }

      // Create proposal — price is dynamic (reference line 65)
      // force:true needed because Bubble animates the button ("not stable")
      log('STEP 15', 'Clicking Create Proposal...');
      await page.getByRole('button', { name: /Create Proposal/ }).click({ force: true });
      await page.waitForTimeout(5000);
      await screenshot(page, '11-proposal-created');

      // PRICE CAPTURE: Proposal modal prices
      const proposalPrices = await scrapePrices(page, {
        pricePerNight: async (p) =&gt; {
          const el = p.locator('text=/Price per night.*\\$[\\d,.]+/i').first();
          return (await el.textContent({ timeout: 5000 })).trim();
        },
        totalReservation: async (p) =&gt; {
          const el = p.locator('text=/Total price for reservation.*\\$[\\d,.]+/i').first();
          return (await el.textContent({ timeout: 5000 })).trim();
        },
        firstFourWeeks: async (p) =&gt; {
          const el = p.locator('text=/Price for the 1st 4 weeks.*\\$[\\d,.]+/i').first();
          return (await el.textContent({ timeout: 5000 })).trim();
        },
      });
      logPrice('PROPOSAL', 'Proposal creation prices', proposalPrices);

      // Submit proposal (reference line 66)
      log('STEP 15', 'Clicking Submit Proposal...');
      await page.getByRole('button', { name: 'Submit Proposal' }).click();
      await page.waitForTimeout(10000);
      await screenshot(page, '12-proposal-submitted');

      // ======================================================================
      // STEP 16: Guest signs out (reference lines 67-71)
      // After proposal submit, page may be scrolled and overlays may be present.
      // Reference: click notification icons → dismiss greyout → avatar → Sign Out
      // ======================================================================
      log('STEP 16', 'Signing out guest...');
      // Scroll to top so avatar is in viewport
      await page.evaluate(() =&gt; window.scrollTo(0, 0));
      await page.waitForTimeout(1000);
      // Dismiss notification icons if present (reference lines 67-68)
      try {
        const notifIcon = page.locator('.bubble-element.Icon.cvaAaIi12');
        if (await notifIcon.first().isVisible({ timeout: 3000 })) {
          await notifIcon.first().click();
          await page.waitForTimeout(500);
          // Click again if still visible (reference clicks twice)
          if (await notifIcon.first().isVisible({ timeout: 1000 })) {
            await notifIcon.first().click();
            await page.waitForTimeout(500);
          }
        }
      } catch (e) { /* no notification icon */ }
      // Dismiss greyout overlay if present (reference line 69)
      try {
        const greyout = page.locator('.greyout').first();
        if (await greyout.isVisible({ timeout: 3000 })) {
          await greyout.click();
          await page.waitForTimeout(1000);
        }
      } catch (e) { /* no overlay */ }
      // Avatar → Sign Out (reference lines 70-71)
      // Avatar may be outside viewport after proposal submit — use JS click to bypass
      await page.locator('.bubble-element.Image.cmaRhaT &gt; img').evaluate((el) =&gt; el.click());
      await page.waitForTimeout(1500);
      await page.getByText('Sign Out').click();
      await page.waitForTimeout(10000);
      await screenshot(page, '13-guest-signed-out');

      log('PHASE 2', '========== PROPOSAL CREATION COMPLETE ==========');

      // ==================================================================
      //  PHASE 3: HOST COUNTERS PROPOSAL
      // ==================================================================
      log('PHASE 3', '========== HOST COUNTERS PROPOSAL ==========');

      // ======================================================================
      // STEP 17: Host signs in (reference lines 74-83)
      // ======================================================================
      await loginAs(page, CONFIG.host.email, CONFIG.host.password, 'STEP 17');
      await screenshot(page, '14-host-logged-in-again');

      // ======================================================================
      // STEP 18: Host navigates to proposals (reference lines 84-87)
      // ======================================================================
      log('STEP 18', 'Opening avatar dropdown...');
      await page.locator('.bubble-element.Image.cmaRhaT &gt; img').click();
      await page.waitForTimeout(1500);

      log('STEP 18', 'Clicking Listings &amp; Proposals...');
      await page.getByText('Listings &amp; Proposals').click();
      log('STEP 18', 'Waiting for dashboard (30s)...');
      await page.waitForTimeout(30000);
      await screenshot(page, '15-host-dashboard-proposals');

      // Click notification icon to open messages/notifications dropdown
      log('STEP 18', 'Clicking notification icon...');
      await page.locator('#letter-hover &gt; img').click();
      await page.waitForTimeout(3000);

      // Click the notification related to our listing (codegen: dynamic text with listing title)
      // Match on "Related to: &lt;listing title&gt;" — the title is known from Phase 1
      const listingTitle = CONFIG.listing.title;
      log('STEP 18', `Looking for notification about "${listingTitle}"...`);
      await page.getByText(new RegExp(`Related to: ${listingTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&amp;')}`)).first().click();
      await page.waitForTimeout(3000);

      // Click "View this proposal" button in the notification detail
      log('STEP 18', 'Clicking View this proposal...');
      await page.getByRole('button', { name: 'View this proposal' }).click();
      await page.waitForTimeout(15000);
      await screenshot(page, '16-proposal-page');

      // ======================================================================
      // STEP 19: Host reviews and modifies proposal (codegen lines 15-21)
      // ======================================================================
      log('STEP 19', 'Clicking Review / Modify...');
      await page.getByRole('button', { name: 'Review / Modify' }).click();
      await page.waitForTimeout(10000);
      await screenshot(page, '17-proposal-review');

      log('STEP 19', 'Clicking Edit Proposal Terms...');
      await page.getByText('Edit Proposal Terms (Nights,').click();
      await page.waitForTimeout(5000);

      log('STEP 19', 'Changing duration to 10 weeks...');
      await page.getByRole('combobox').nth(1).selectOption(BUBBLE_VALUES.proposal.duration10Weeks);
      await page.waitForTimeout(2000);
      await screenshot(page, '18-terms-edited');

      log('STEP 19', 'Clicking Update Proposal...');
      await page.getByRole('button', { name: 'Update Proposal' }).click();
      await page.waitForTimeout(3000);

      log('STEP 19', 'Confirming — Yes, Proceed...');
      await page.getByRole('button', { name: 'Yes, Proceed' }).click();
      await page.waitForTimeout(10000);
      await screenshot(page, '19-proposal-countered');

      // PRICE CAPTURE: Counter-offer prices (from the proposal summary modal)
      const counterPrices = await scrapePrices(page, {
        compensationPerNight: async (p) =&gt; {
          const el = p.locator('text=/Compensation per Night.*\\$[\\d,.]+/i').first();
          return (await el.textContent({ timeout: 5000 })).trim();
        },
        duration: async (p) =&gt; {
          const el = p.locator('text=/Duration/i').first();
          const row = el.locator('..');
          return (await row.textContent({ timeout: 5000 })).trim();
        },
        total: async (p) =&gt; {
          const el = p.locator('text=/\\$[\\d,.]+\\s+Total/i').first();
          return (await el.textContent({ timeout: 5000 })).trim();
        },
      });
      logPrice('COUNTER', 'Host counter-offer prices', counterPrices);

      // ======================================================================
      // STEP 20: Host signs out (reference lines 93-94)
      // After counter, a greyout overlay appears — click it, then Sign Out
      // ======================================================================
      log('STEP 20', 'Signing out host...');
      // After counter, a proposal summary modal appears — close it first
      try {
        // Try closing via X button on the modal
        const closeBtn = page.locator('button:has-text("×"), [class*="close"], .bubble-element.close-icon').first();
        if (await closeBtn.isVisible({ timeout: 3000 })) {
          await closeBtn.click();
          await page.waitForTimeout(1000);
        }
      } catch (e) { /* no close button */ }
      // Dismiss greyout overlay if still present
      try {
        const greyout = page.locator('.greyout').first();
        if (await greyout.isVisible({ timeout: 3000 })) {
          await greyout.click();
          await page.waitForTimeout(1000);
        }
      } catch (e) { /* no overlay */ }
      // Use JS click on avatar to bypass any remaining overlays
      await page.locator('.bubble-element.Image.cmaRhaT &gt; img').evaluate((el) =&gt; el.click());
      await page.waitForTimeout(1500);
      await page.getByText('Sign Out').click();
      await page.waitForTimeout(10000);
      await screenshot(page, '20-host-signed-out-again');

      log('PHASE 3', '========== HOST COUNTER COMPLETE ==========');

      // ==================================================================
      //  PHASE 4: GUEST ACCEPTS HOST TERMS
      // ==================================================================
      log('PHASE 4', '========== GUEST ACCEPTS HOST TERMS ==========');

      // ======================================================================
      // STEP 21: Guest signs in (reference lines 95-107)
      // ======================================================================
      await loginAs(page, CONFIG.guest.email, CONFIG.guest.password, 'STEP 21');
      await screenshot(page, '21-guest-logged-in-again');

      // ======================================================================
      // STEP 22: Guest navigates to proposals and accepts
      // Reference line 108: click host name text, then "My Proposals"
      // The host's display name on Bubble is "Test" for rodtesthost2 account
      // ======================================================================
      log('STEP 22', 'Looking for host name or proposals link...');
      try {
        // Try clicking host name "Test" (reference used "Rod" — depends on account)
        await page.getByText('Test', { exact: true }).first().click();
        await page.waitForTimeout(3000);
      } catch (e) {
        log('STEP 22', '"Test" text not found — trying avatar...');
        await page.locator('.bubble-element.Image.cmaRhaT &gt; img').click();
        await page.waitForTimeout(1500);
      }

      log('STEP 22', 'Clicking My Proposals...');
      await page.getByText('My Proposals').click();
      await page.waitForTimeout(15000);
      await screenshot(page, '22-guest-proposals');

      // PRICE CAPTURE: Guest view before acceptance
      const acceptancePrices = await scrapePrices(page, {
        nightlyRate: async (p) =&gt; {
          const el = p.locator('text=/\\$[\\d,.]+\\s*\\/\\s*night/i').first();
          return (await el.textContent({ timeout: 5000 })).trim();
        },
        duration: async (p) =&gt; {
          const el = p.locator('text=/Duration/i').first();
          const row = el.locator('..');
          return (await row.textContent({ timeout: 5000 })).trim();
        },
        total: async (p) =&gt; {
          const el = p.locator('text=/\\$[\\d,.]+\\s+in total/i').first();
          return (await el.textContent({ timeout: 5000 })).trim();
        },
      });
      logPrice('ACCEPTANCE', 'Guest acceptance prices', acceptancePrices);

      // Accept host terms (reference lines 110-111)
      log('STEP 22', 'Clicking Accept Host Terms...');
      await page.getByRole('button', { name: 'Accept Host Terms' }).click();
      await page.waitForTimeout(3000);

      log('STEP 22', 'Confirming — Yes, Proceed...');
      await page.getByRole('button', { name: 'Yes, Proceed' }).click();
      await page.waitForTimeout(10000);
      await screenshot(page, '23-terms-accepted');

      log('PHASE 4', '========== GUEST ACCEPTANCE COMPLETE ==========');
    }

    // ====================================================================
    //  FINAL: Backend Verification
    // ====================================================================
    log('FINAL', 'Running Backend Observer...');
    await runBackendObserver();

    log('DONE', '==============================================');
    log('DONE', '  FULL FLOW COMPLETED SUCCESSFULLY');
    log('DONE', '==============================================');
    log('DONE', `Listing: "${CONFIG.listing.title}"`);
    log('DONE', `Listing URL: ${listingViewURL || 'N/A'}`);
    log('DONE', `Screenshots: ${screenshotsDir}`);
    log('DONE', `Video: ${recordingsDir}`);
    log('DONE', `Price Log: ${priceLogPath} (${priceLog.length} entries)`);

  } catch (error) {
    log('ERROR', `Script failed: ${error.message}`);
    await screenshot(page, 'ERROR-final-state').catch(() =&gt; {});
    console.error(error);
  } finally {
    const videoPath = await page.video()?.path();
    await context.close();
    await browser.close();
    if (videoPath) log('VIDEO', `Recording saved: ${videoPath}`);
  }
})();
</code></pre>
      </div>
    </div>
  </div>

  <div class="proposal">
    <div class="proposal__header">
      <h3>Agent 2: bubble-price-tracker.cjs</h3>
      <span class="proposal__impact impact--agent2">580 lines</span>
      <span class="proposal__effort">Bubble API</span>
    </div>
    <p>The headless API poller. Watches for Agent 1’s signal file, then polls the Bubble Data API every 10 seconds to capture backend price data and diffs across the proposal lifecycle.</p>
    <button class="code-toggle" aria-expanded="false" onclick="toggleCode(this)">
      <span class="arrow">&#9654;</span> Show source code
    </button>
    <div class="code-collapse">
      <div class="code-section">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code id="agent2-code">/**
 * Agent 2: Bubble Backend Price Tracker
 *
 * Runs in parallel with the E2E journey script (proposal-journey-bubble.cjs).
 * Watches for a listing signal file, then polls the Bubble Data API
 * to capture backend price data at each stage of the proposal lifecycle.
 *
 * Tracks: Listing price, Proposal price, Counter-offer, Final lease price
 * All via Bubble Data API (no browser scraping).
 *
 * Usage:
 *   node bubble-price-tracker.cjs [--site=app.split.lease] [--api-key=&lt;key&gt;]
 *
 * The tracker watches for a signal file written by Agent 1 after listing creation,
 * then periodically queries the Bubble Data API for data changes.
 */

const path = require('path');
const fs = require('fs');

// ============================================================================
// Site Profiles (must match proposal-journey-bubble.cjs)
// ============================================================================

const SITE_PROFILES = {
  'app.split.lease': {
    baseURL: 'https://app.split.lease',
    apiBase: 'https://app.split.lease/api/1.1/obj',
  },
  'split.lease': {
    baseURL: 'https://split.lease',
    apiBase: 'https://split.lease/api/1.1/obj',
  },
};

// Parse CLI args
const siteArg = process.argv.find((a) =&gt; a.startsWith('--site='));
const siteName = siteArg ? siteArg.split('=')[1] : 'app.split.lease';
const siteProfile = SITE_PROFILES[siteName];

const apiKeyArg = process.argv.find((a) =&gt; a.startsWith('--api-key='));
const BUBBLE_API_KEY = apiKeyArg
  ? apiKeyArg.split('=').slice(1).join('=')
  : process.env.BUBBLE_API_KEY || process.env.VITE_BUBBLE_API_KEY || '5dbb448f9a6bbb043cb56ac16b8de109';

if (!siteProfile) {
  console.error(`Unknown site: ${siteName}. Available: ${Object.keys(SITE_PROFILES).join(', ')}`);
  process.exit(1);
}

const safeSiteName = siteName.replace(/\./g, '-');
const siteDir = path.join(__dirname, 'recordings', safeSiteName);

// ============================================================================
// Logging
// ============================================================================

function log(tag, message) {
  const time = new Date().toLocaleTimeString('en-US', { hour12: true });
  console.log(`[${time}] [${tag}] ${message}`);
}

// ============================================================================
// Bubble Data API Client
// ============================================================================

async function bubbleGet(objectType, constraints = [], sortField = null, descending = true, limit = 10) {
  const url = new URL(`${siteProfile.apiBase}/${objectType}`);
  if (constraints.length &gt; 0) {
    url.searchParams.set('constraints', JSON.stringify(constraints));
  }
  if (sortField) {
    url.searchParams.set('sort_field', sortField);
    url.searchParams.set('descending', descending ? 'true' : 'false');
  }
  url.searchParams.set('limit', String(limit));

  const response = await fetch(url.toString(), {
    headers: {
      Authorization: `Bearer ${BUBBLE_API_KEY}`,
      'Content-Type': 'application/json',
    },
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Bubble API ${response.status}: ${errorText}`);
  }

  const data = await response.json();
  return data.response?.results || [];
}

async function bubbleGetById(objectType, uniqueId) {
  const url = `${siteProfile.apiBase}/${objectType}/${uniqueId}`;

  const response = await fetch(url, {
    headers: {
      Authorization: `Bearer ${BUBBLE_API_KEY}`,
      'Content-Type': 'application/json',
    },
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Bubble API ${response.status}: ${errorText}`);
  }

  const data = await response.json();
  return data.response;
}

// ============================================================================
// Field extractors - pull pricing-related fields from Bubble objects
// ============================================================================

function extractListingPriceFields(listing) {
  return {
    _id: listing._id,
    Name: listing.Name || null,
    'rental type': listing['rental type'] || null,
    // Nightly host rates by number of nights
    'Nightly Host Rate for 2 nights': listing['💰Nightly Host Rate for 2 nights'] ?? null,
    'Nightly Host Rate for 3 nights': listing['💰Nightly Host Rate for 3 nights'] ?? null,
    'Nightly Host Rate for 4 nights': listing['💰Nightly Host Rate for 4 nights'] ?? null,
    'Nightly Host Rate for 5 nights': listing['💰Nightly Host Rate for 5 nights'] ?? null,
    'Nightly Host Rate for 7 nights': listing['💰Nightly Host Rate for 7 nights'] ?? null,
    'Cleaning Cost / Maintenance Fee': listing['💰Cleaning Cost / Maintenance Fee'] ?? null,
    'Damage Deposit': listing['💰Damage Deposit'] ?? null,
    'Unit Markup': listing['💰Unit Markup'] ?? null,
    'Standarized Minimum Nightly Price (Filter)': listing['Standarized Minimum Nightly Price (Filter)'] ?? null,
    'Price number (for map)': listing['Price number (for map)'] || null,
    'pricing_list': listing['pricing_list'] || null,
    // Schedule
    'Minimum Nights': listing['Minimum Nights'] ?? null,
    'Maximum Nights': listing['Maximum Nights'] ?? null,
    'Minimum Weeks': listing['Minimum Weeks'] ?? null,
    'Maximum Weeks': listing['Maximum Weeks'] ?? null,
    'Weeks offered': listing['Weeks offered'] || null,
    '# of nights available': listing['# of nights available'] ?? null,
    Active: listing.Active,
    Complete: listing.Complete,
    'Modified Date': listing['Modified Date'],
  };
}

function extractProposalPriceFields(proposal) {
  return {
    _id: proposal._id,
    'Host - Account': proposal['Host - Account'] || null,
    Listing: proposal.Listing || null,
    Status: proposal.Status || null,
    // Pricing fields (actual Bubble field names)
    'proposal nightly price': proposal['proposal nightly price'] ?? null,
    'host compensation': proposal['host compensation'] ?? null,
    '4 week rent': proposal['4 week rent'] ?? null,
    'Total Compensation (proposal - host)': proposal['Total Compensation (proposal - host)'] ?? null,
    'Total Price for Reservation (guest)': proposal['Total Price for Reservation (guest)'] ?? null,
    'cleaning fee': proposal['cleaning fee'] ?? null,
    'damage deposit': proposal['damage deposit'] ?? null,
    // Duration / schedule
    'Reservation Span': proposal['Reservation Span'] || null,
    'Reservation Span (Weeks)': proposal['Reservation Span (Weeks)'] ?? null,
    'actual weeks during reservation span': proposal['actual weeks during reservation span'] ?? null,
    'nights per week (num)': proposal['nights per week (num)'] ?? null,
    'Days Selected': proposal['Days Selected'] || null,
    'Nights Selected (Nights list)': proposal['Nights Selected (Nights list)'] || null,
    'check in day': proposal['check in day'] || null,
    'check out day': proposal['check out day'] || null,
    'week selection': proposal['week selection'] || null,
    // Dates
    'Move in range start': proposal['Move in range start'] || null,
    'Move-out': proposal['Move-out'] || null,
    // Status tracking
    'Is Finalized': proposal['Is Finalized'] ?? null,
    'rental type': proposal['rental type'] || null,
    History: proposal.History || null,
    'Created Date': proposal['Created Date'],
    'Modified Date': proposal['Modified Date'],
  };
}

// ============================================================================
// Diff helper - detect what changed between two snapshots
// ============================================================================

function diffSnapshots(prev, curr) {
  if (!prev) return { changed: true, isNew: true, fields: curr };

  const changes = {};
  let hasChanges = false;
  const allKeys = new Set([...Object.keys(prev), ...Object.keys(curr)]);

  for (const key of allKeys) {
    if (key === 'Modified Date' || key === 'Created Date') continue;
    const prevVal = JSON.stringify(prev[key]);
    const currVal = JSON.stringify(curr[key]);
    if (prevVal !== currVal) {
      changes[key] = { from: prev[key], to: curr[key] };
      hasChanges = true;
    }
  }

  return { changed: hasChanges, isNew: false, fields: hasChanges ? changes : null };
}

// ============================================================================
// Wait for signal file from Agent 1
// ============================================================================

async function waitForSignal(timeoutMs = 600000) {
  log('TRACKER', `Watching for listing signal in ${siteDir}...`);
  log('TRACKER', `Timeout: ${timeoutMs / 1000}s`);

  const startTime = Date.now();
  const pollIntervalMs = 3000;

  while (Date.now() - startTime &lt; timeoutMs) {
    const latestPath = path.join(siteDir, 'latest.txt');
    if (fs.existsSync(latestPath)) {
      const runTimestamp = fs.readFileSync(latestPath, 'utf8').trim();
      const signalPath = path.join(siteDir, runTimestamp, 'listing-signal.json');

      if (fs.existsSync(signalPath)) {
        const signal = JSON.parse(fs.readFileSync(signalPath, 'utf8'));
        log('TRACKER', `Signal found: listing ${signal.listingId}`);
        log('TRACKER', `Listing URL: ${signal.listingURL}`);
        return { ...signal, runDir: path.join(siteDir, runTimestamp) };
      }
    }

    await new Promise((resolve) =&gt; setTimeout(resolve, pollIntervalMs));
  }

  throw new Error('Timeout waiting for listing signal from Agent 1');
}

// ============================================================================
// Main tracker
// ============================================================================

(async () =&gt; {
  log('TRACKER', '========== BUBBLE BACKEND PRICE TRACKER ==========');
  log('TRACKER', `Site: ${siteName} (${siteProfile.baseURL})`);
  log('TRACKER', `API Base: ${siteProfile.apiBase}`);
  log('TRACKER', `API Key: ${BUBBLE_API_KEY.slice(0, 8)}...`);

  // Wait for Agent 1 to create the listing and write the signal file
  const signal = await waitForSignal();

  const trackerLog = [];
  const trackerLogPath = path.join(signal.runDir, 'backend-price-tracker-log.json');

  // State tracking for diffs
  let lastListingSnapshot = null;
  let lastProposalSnapshot = null;
  let proposalId = null;

  function addEntry(phase, label, data) {
    const entry = {
      timestamp: new Date().toISOString(),
      phase,
      label,
      ...data,
    };
    trackerLog.push(entry);
    fs.writeFileSync(trackerLogPath, JSON.stringify(trackerLog, null, 2));
    log('PRICE', `[${phase}] ${label}`);
  }

  try {
    // ==================================================================
    // PHASE 1: Fetch initial listing data from Bubble
    // ==================================================================
    log('PHASE 1', 'Fetching listing from Bubble Data API...');

    const listingId = signal.listingId;
    let listingData;

    // Try direct ID lookup first, fall back to search by name
    try {
      listingData = await bubbleGetById('listing', listingId);
    } catch (e) {
      log('PHASE 1', `Direct lookup failed (${e.message}), searching by name...`);
      const results = await bubbleGet('listing', [
        { key: 'Name', constraint_type: 'equals', value: signal.listingTitle },
      ], 'Created Date', true, 1);
      listingData = results[0] || null;
    }

    if (listingData) {
      lastListingSnapshot = extractListingPriceFields(listingData);
      addEntry('LISTING_CREATED', 'Initial listing backend data', {
        listingId: lastListingSnapshot._id,
        snapshot: lastListingSnapshot,
      });

      // Log all raw fields for debugging (first time only)
      const rawFieldsPath = path.join(signal.runDir, 'listing-raw-fields.json');
      fs.writeFileSync(rawFieldsPath, JSON.stringify(listingData, null, 2));
      log('PHASE 1', `Full listing raw fields saved to: ${rawFieldsPath}`);
    } else {
      log('PHASE 1', 'WARNING: Listing not found in Bubble API');
      addEntry('LISTING_CREATED', 'Listing NOT FOUND in Bubble API', { listingId });
    }

    // ==================================================================
    // PHASE 2-4: Poll for proposal creation, counter-offer, acceptance
    // ==================================================================
    log('PHASE 2', 'Polling Bubble API for proposal and price changes...');

    const pollIntervalMs = 10000; // 10 seconds
    const maxPolls = 60; // 60 * 10s = ~10 minutes max
    let phase = 'WAITING_FOR_PROPOSAL';
    let proposalRawFieldsSaved = false;

    for (let i = 0; i &lt; maxPolls; i++) {
      try {
        // --- Check for proposal linked to this listing ---
        if (!proposalId) {
          const proposals = await bubbleGet('Proposal', [
            { key: 'Listing', constraint_type: 'equals', value: listingId },
          ], 'Created Date', true, 5);

          if (proposals.length &gt; 0) {
            const proposal = proposals[0];
            proposalId = proposal._id;
            lastProposalSnapshot = extractProposalPriceFields(proposal);

            addEntry('PROPOSAL_CREATED', 'Proposal detected in Bubble backend', {
              proposalId,
              snapshot: lastProposalSnapshot,
            });

            // Save raw proposal fields once
            if (!proposalRawFieldsSaved) {
              const rawPath = path.join(signal.runDir, 'proposal-raw-fields.json');
              fs.writeFileSync(rawPath, JSON.stringify(proposal, null, 2));
              log('PHASE 2', `Full proposal raw fields saved to: ${rawPath}`);
              proposalRawFieldsSaved = true;
            }

            phase = 'WATCHING_PROPOSAL';
          }
        }

        // --- Poll existing proposal for changes (counter-offer, acceptance) ---
        if (proposalId) {
          let currentProposal;
          try {
            currentProposal = await bubbleGetById('Proposal', proposalId);
          } catch (e) {
            // Fall back to search
            const results = await bubbleGet('Proposal', [
              { key: '_id', constraint_type: 'equals', value: proposalId },
            ]);
            currentProposal = results[0] || null;
          }

          if (currentProposal) {
            const currentSnapshot = extractProposalPriceFields(currentProposal);
            const diff = diffSnapshots(lastProposalSnapshot, currentSnapshot);

            if (diff.changed &amp;&amp; !diff.isNew) {
              // Determine what kind of change this is
              const statusChange = diff.fields?.Status;
              const counterChange = diff.fields?.['host compensation'] || diff.fields?.['proposal nightly price'] || diff.fields?.['Reservation Span (Weeks)'] || diff.fields?.['Total Compensation (proposal - host)'];
              const acceptedChange = diff.fields?.['Is Finalized'];

              let changePhase = 'PROPOSAL_UPDATED';
              let changeLabel = 'Proposal data changed';

              if (counterChange || (statusChange &amp;&amp; String(statusChange.to).toLowerCase().includes('counter'))) {
                changePhase = 'COUNTER_OFFER';
                changeLabel = 'Counter-offer detected in Bubble backend';
              } else if (acceptedChange || (statusChange &amp;&amp; String(statusChange.to).toLowerCase().includes('accept'))) {
                changePhase = 'ACCEPTED';
                changeLabel = 'Proposal acceptance detected in Bubble backend';
              } else if (statusChange) {
                changePhase = 'STATUS_CHANGE';
                changeLabel = `Proposal status changed: ${statusChange.from} -&gt; ${statusChange.to}`;
              }

              addEntry(changePhase, changeLabel, {
                proposalId,
                changes: diff.fields,
                snapshot: currentSnapshot,
              });

              lastProposalSnapshot = currentSnapshot;

              // Save updated raw fields on each change
              const rawPath = path.join(signal.runDir, `proposal-raw-fields-${changePhase.toLowerCase()}.json`);
              fs.writeFileSync(rawPath, JSON.stringify(currentProposal, null, 2));

              // Stop if acceptance detected
              if (changePhase === 'ACCEPTED') {
                log('PHASE 4', 'Acceptance detected in Bubble backend. Stopping tracker.');
                break;
              }
            }
          }
        }

        // --- Also re-check listing for price changes (listing could be modified) ---
        if (listingData) {
          try {
            let currentListing;
            try {
              currentListing = await bubbleGetById('listing', listingId);
            } catch (e) {
              const results = await bubbleGet('listing', [
                { key: '_id', constraint_type: 'equals', value: listingId },
              ]);
              currentListing = results[0] || null;
            }

            if (currentListing) {
              const currentListingSnapshot = extractListingPriceFields(currentListing);
              const listingDiff = diffSnapshots(lastListingSnapshot, currentListingSnapshot);

              if (listingDiff.changed &amp;&amp; !listingDiff.isNew) {
                addEntry('LISTING_UPDATED', 'Listing data changed in Bubble backend', {
                  listingId,
                  changes: listingDiff.fields,
                  snapshot: currentListingSnapshot,
                });
                lastListingSnapshot = currentListingSnapshot;
              }
            }
          } catch (e) {
            // Non-fatal — listing check is secondary
          }
        }

        // --- Check Agent 1 signal for early termination ---
        try {
          const agent1PriceLogPath = path.join(signal.runDir, 'price-log.json');
          if (fs.existsSync(agent1PriceLogPath)) {
            const agent1Log = JSON.parse(fs.readFileSync(agent1PriceLogPath, 'utf8'));
            const hasAcceptance = agent1Log.some((e) =&gt; e.phase === 'ACCEPTANCE');
            if (hasAcceptance) {
              log('TRACKER', 'Agent 1 logged acceptance — doing final backend snapshot...');

              // One last fetch to capture final state
              await new Promise((resolve) =&gt; setTimeout(resolve, 5000));

              if (proposalId) {
                try {
                  const finalProposal = await bubbleGetById('Proposal', proposalId);
                  const finalSnapshot = extractProposalPriceFields(finalProposal);
                  const finalDiff = diffSnapshots(lastProposalSnapshot, finalSnapshot);
                  if (finalDiff.changed) {
                    addEntry('FINAL_STATE', 'Final proposal state after acceptance', {
                      proposalId,
                      changes: finalDiff.fields,
                      snapshot: finalSnapshot,
                    });
                  } else {
                    addEntry('FINAL_STATE', 'Final proposal state (no additional changes)', {
                      proposalId,
                      snapshot: finalSnapshot,
                    });
                  }
                } catch (e) {
                  log('TRACKER', `Final proposal fetch failed: ${e.message}`);
                }
              }

              break;
            }
          }
        } catch (e) {
          // File may be mid-write
        }

      } catch (e) {
        log('ERROR', `Poll error: ${e.message}`);
      }

      await new Promise((resolve) =&gt; setTimeout(resolve, pollIntervalMs));
      log('TRACKER', `Poll ${i + 1}/${maxPolls} | Phase: ${phase} | Proposal: ${proposalId || 'not yet'}`);
    }

    // ==================================================================
    // FINAL: Generate summary report
    // ==================================================================
    log('FINAL', '========== BACKEND PRICE TRACKING COMPLETE ==========');

    const summaryPath = path.join(signal.runDir, 'backend-price-summary.txt');
    const summaryLines = [
      '=== BUBBLE BACKEND PRICE TRACKER --- SUMMARY ===',
      `Site: ${siteName}`,
      `API Base: ${siteProfile.apiBase}`,
      `Listing: ${signal.listingTitle}`,
      `Listing ID: ${listingId}`,
      `Proposal ID: ${proposalId || 'N/A'}`,
      `Timestamp: ${new Date().toISOString()}`,
      `Total events captured: ${trackerLog.length}`,
      '',
      '--- TIMELINE ---',
      '',
    ];

    for (const entry of trackerLog) {
      summaryLines.push(`[${entry.timestamp}] ${entry.phase} - ${entry.label}`);

      if (entry.changes) {
        summaryLines.push('  Changes:');
        for (const [key, val] of Object.entries(entry.changes)) {
          if (val &amp;&amp; typeof val === 'object' &amp;&amp; 'from' in val) {
            summaryLines.push(`    ${key}: ${JSON.stringify(val.from)} -&gt; ${JSON.stringify(val.to)}`);
          } else {
            summaryLines.push(`    ${key}: ${JSON.stringify(val)}`);
          }
        }
      }

      if (entry.snapshot) {
        summaryLines.push('  Price fields:');
        for (const [key, val] of Object.entries(entry.snapshot)) {
          if (key.startsWith('_') || key === 'Modified Date' || key === 'Created Date') continue;
          if (val !== null &amp;&amp; val !== undefined) {
            summaryLines.push(`    ${key}: ${JSON.stringify(val)}`);
          }
        }
      }

      summaryLines.push('');
    }

    // Price comparison table
    summaryLines.push('--- PRICE COMPARISON ACROSS PHASES ---');
    summaryLines.push('');

    const priceFields = [
      'proposal nightly price', 'host compensation', '4 week rent',
      'Total Compensation (proposal - host)', 'Total Price for Reservation (guest)',
      'cleaning fee', 'damage deposit',
      'Reservation Span', 'Reservation Span (Weeks)', 'nights per week (num)',
      'Days Selected', 'check in day', 'check out day',
      'Move in range start', 'Move-out', 'Is Finalized',
    ];

    const phases = trackerLog.filter((e) =&gt; e.snapshot);
    if (phases.length &gt; 0) {
      // Header
      const header = 'Field'.padEnd(30) + phases.map((p) =&gt; p.phase.padEnd(25)).join('');
      summaryLines.push(header);
      summaryLines.push('-'.repeat(header.length));

      for (const field of priceFields) {
        const values = phases.map((p) =&gt; {
          const val = p.snapshot?.[field];
          return (val !== null &amp;&amp; val !== undefined ? String(val) : '-').padEnd(25);
        });
        const hasValue = values.some((v) =&gt; v.trim() !== '-');
        if (hasValue) {
          summaryLines.push(field.padEnd(30) + values.join(''));
        }
      }
    }

    summaryLines.push('');
    summaryLines.push('=== END OF REPORT ===');

    fs.writeFileSync(summaryPath, summaryLines.join('\n'));
    log('FINAL', `Backend price summary: ${summaryPath}`);
    log('FINAL', `Full tracker log: ${trackerLogPath} (${trackerLog.length} entries)`);
    log('FINAL', `Raw listing fields: ${path.join(signal.runDir, 'listing-raw-fields.json')}`);
    if (proposalId) {
      log('FINAL', `Raw proposal fields: ${path.join(signal.runDir, 'proposal-raw-fields.json')}`);
    }

  } catch (error) {
    log('ERROR', `Tracker failed: ${error.message}`);
    console.error(error);
  }
})();
</code></pre>
      </div>
    </div>
  </div>
</div>

</div>

<script>
function toggleCode(btn) {
  const collapse = btn.nextElementSibling;
  const isOpen = collapse.classList.contains('open');
  collapse.classList.toggle('open');
  btn.setAttribute('aria-expanded', !isOpen);
  btn.querySelector('.arrow').style.transform = isOpen ? '' : 'rotate(90deg)';
  const label = btn.textContent.trim().replace(/[^a-zA-Z ]/g, '').trim();
  btn.innerHTML = '<span class="arrow" style="transform:' + (isOpen ? '' : 'rotate(90deg)') + '">&#9654;</span> ' + (isOpen ? 'Show' : 'Hide') + ' source code';
}

function copyCode(btn) {
  const codeEl = btn.parentElement.querySelector('code');
  const text = codeEl.textContent;
  navigator.clipboard.writeText(text).then(() => {
    btn.textContent = 'Copied!';
    btn.classList.add('copied');
    setTimeout(() => {
      btn.textContent = 'Copy';
      btn.classList.remove('copied');
    }, 2000);
  });
}
</script>

</body>
</html>